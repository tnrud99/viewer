<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Window-Viewer - Synchronized Reaction Video Player</title>
    <link rel="icon" href="favicon.ico">

    
    <!-- 독립적인 스타일 (ui-system.css 참조하지 않음) -->
    <style>
        :root {
            /* 색상 시스템 */
            --color-action: #c2291f;
            --color-action-hover: #a81f18;
            --color-action-light: rgba(194, 41, 31, 0.1);
            --color-secondary: #4a4a4a;
            --color-secondary-hover: #5a5a5a;
            --color-success: #4caf50;
            --color-warning: #ff9800;
            --color-error: #f44336;
            --color-info: #2196f3;
            --color-bg-main: #1a1a1a;
            --color-bg-card: rgba(42, 42, 42, 0.8);
            --color-bg-input: rgba(58, 58, 58, 0.6);
            --color-text-main: #ffffff;
            --color-text-sub: #cccccc;
            --color-text-muted: #888888;
            --color-border: rgba(255, 255, 255, 0.1);
            --color-border-focus: rgba(194, 41, 31, 0.3);
            
            /* 간격 */
            --space-xs: 0.5rem;
            --space-sm: 0.75rem;
            --space-md: 1rem;
            --space-lg: 1.5rem;
            --space-xl: 2rem;
            
            /* 폰트 크기 */
            --text-xs: 0.75rem;
            --text-sm: 0.875rem;
            --text-base: 1rem;
            --text-lg: 1.125rem;
            --text-xl: 1.25rem;
            --text-2xl: 1.5rem;
            --text-3xl: 2rem;
            
            /* 둥근 모서리 */
            --radius-sm: 0.5rem;
            --radius-md: 0.75rem;
            --radius-lg: 1rem;
            --radius-xl: 1.5rem;
            
            /* 그림자 */
            --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.1);
            --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.2);
            --shadow-lg: 0 8px 16px rgba(0, 0, 0, 0.3);
            --shadow-action: 0 4px 12px rgba(194, 41, 31, 0.3);
            
            /* 애니메이션 */
            --transition: 0.2s ease;
            --transition-slow: 0.3s ease;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, var(--color-bg-main) 0%, #2a2a2a 100%);
            color: var(--color-text-main);
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: var(--space-lg);
            min-height: 100vh;
        }

        /* Header with Logo & Navigation */
        .header {
            text-align: center;
            margin-bottom: var(--space-xl);
            padding: var(--space-lg) 0 var(--space-sm) 0;
        }

        .header-content {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-xxl);
            position: relative;
            width: 100%;
        }

        .header-center {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            padding-top: var(--space-md);
        }

        .header-logo {
            width: 40px;
            height: 40px;
            background-image: url('./logo/whitered_mini.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        .header h1 {
            color: var(--color-text-main);
            font-size: var(--text-3xl);
            font-weight: 600;
            margin: 0;
            letter-spacing: 0.02em;
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .beta-tag {
            background: var(--color-action);
            color: white;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.4em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-left: 4px;
            margin-top: 5px;
        }

        .header p {
            color: var(--color-text-sub);
            font-size: var(--text-base);
            margin: var(--space-xs) 0 0 0;
            line-height: 1.6;
        }

        /* Info Icon - URL creator와 통일 */
        .info-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--color-secondary);
            color: white;
            border: none;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: var(--space-xs);
            margin-top: 5px;
            transition: var(--transition);
            z-index: 1000;
            position: relative;
        }

        .info-icon:hover {
            background: var(--color-action);
            transform: scale(1.1);
        }

        .info-icon:active {
            transform: scale(0.95);
        }

        /* Apple-style Info Tooltip */
        .apple-tooltip {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #1e1e1e;
            color: #fff;
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #333;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            font-size: 14px;
            line-height: 1.5;
            width: 500px;
            max-width: 90vw;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            white-space: normal;
            margin-top: 10px;
        }

        .apple-tooltip.show {
            opacity: 1;
            visibility: visible;
        }

        .apple-tooltip::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 8px solid #1e1e1e;
        }

        .apple-tooltip-header {
            margin-bottom: 16px;
        }

        .apple-tooltip-title {
            color: #fff;
            font-size: 18px;
            font-weight: 400;
            margin: 0;
            line-height: 1.2;
        }

        .apple-tooltip-subtitle {
            color: #ff3b30;
            font-size: 12px;
            font-weight: 400;
            margin-top: 4px;
            letter-spacing: 0.5px;
        }

        .apple-tooltip-section {
            margin-bottom: 16px;
        }

        .apple-tooltip-section:last-child {
            margin-bottom: 0;
        }

        .apple-tooltip-section-title {
            color: #fff;
            font-size: 14px;
            font-weight: 400;
            margin: 0 0 8px 0;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .apple-tooltip-section-content {
            color: #ccc;
            font-size: 13px;
            line-height: 1.4;
            margin: 0;
            font-weight: 300;
        }

        .apple-tooltip-highlight {
            background: #2a2a2a;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 12px;
            margin: 12px 0;
        }

        .apple-tooltip-highlight-title {
            color: #ff3b30;
            font-size: 13px;
            font-weight: 400;
            margin: 0 0 6px 0;
        }

        .apple-tooltip-highlight-content {
            color: #ccc;
            font-size: 12px;
            line-height: 1.3;
            margin: 0;
            font-weight: 300;
        }

        /* Create Your Own Button - URL creator와 통일 */
        .create-own-btn {
            background: var(--color-bg-card);
            color: white;
            border: 1px solid var(--color-action);
            border-radius: var(--radius-md);
            padding: var(--space-xs) var(--space-sm);
            font-size: var(--text-sm);
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            box-shadow: var(--shadow-sm);
            backdrop-filter: blur(10px);
            margin-left: 10px;
        }

        .create-own-btn:hover {
            background: var(--color-action);
            color: white;
            transform: scale(1.02);
            box-shadow: var(--shadow-md);
        }

        .create-own-btn:active {
            transform: scale(0.98);
        }

        /* Floating Overlay Settings Panel */
        .overlay-settings-panel {
            position: fixed;
            top: 50%;
            right: var(--space-lg);
            transform: translateY(-50%);
            background: var(--color-bg-card);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-xl);
            padding: var(--space-md);
            box-shadow: var(--shadow-md);
            backdrop-filter: blur(10px);
            z-index: 1000;
            max-width: 280px;
            max-height: 60vh;
            overflow-y: auto;
            transition: all 0.3s ease;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-50%) translateX(100%);
        }

        .overlay-settings-panel.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(-50%) translateX(0);
        }

        .overlay-settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-sm);
            padding-bottom: var(--space-xs);
            border-bottom: 1px solid var(--color-border);
        }

        .overlay-settings-title {
            font-size: var(--text-base);
            font-weight: 600;
            color: var(--color-text-main);
            margin: 0;
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .floating-controls h3 {
            margin-top: 0;
            margin-bottom: var(--space-md);
            color: var(--color-text-main);
            font-size: var(--text-lg);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        /* Compact Controls - Only overlay settings */
        .compact-controls {
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
        }

        .compact-controls .input-group {
            margin-bottom: var(--space-sm);
        }

        .compact-controls .input-label {
            font-size: var(--text-xs);
            margin-bottom: var(--space-xs);
        }

        .compact-controls .input {
            padding: var(--space-xs) var(--space-sm);
            font-size: var(--text-sm);
            min-height: 36px;
        }

        .compact-controls .slider-container {
            margin-top: var(--space-xs);
        }

        .compact-controls .slider-value {
            font-size: var(--text-sm);
            min-width: 40px;
        }

        /* Card System */
        .card {
            background: var(--color-bg-card);
            border-radius: var(--radius-xl);
            padding: var(--space-lg);
            box-shadow: var(--shadow-md);
            border: 1px solid var(--color-border);
            backdrop-filter: blur(10px);
            margin-bottom: var(--space-lg);
        }

        .card-header {
            margin-bottom: var(--space-lg);
            padding-bottom: var(--space-md);
            border-bottom: 1px solid var(--color-border);
        }

        .card-title {
            font-size: var(--text-xl);
            font-weight: 700;
            color: var(--color-text-main);
            margin: 0;
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .card-subtitle {
            font-size: var(--text-base);
            color: var(--color-text-sub);
            margin: var(--space-xs) 0 0 0;
        }

        /* Input System */
        .input-group {
            margin-bottom: var(--space-md);
        }

        .input-label {
            display: block;
            margin-bottom: var(--space-xs);
            color: var(--color-text-main);
            font-weight: 600;
            font-size: var(--text-sm);
        }

        .input {
            width: 100%;
            padding: var(--space-sm) var(--space-md);
            background: var(--color-bg-input);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            color: var(--color-text-main);
            font-size: var(--text-base);
            transition: var(--transition);
            min-height: 44px;
            box-sizing: border-box;
        }

        .input:focus {
            outline: none;
            border-color: var(--color-action);
            box-shadow: 0 0 0 3px var(--color-action-light);
        }

        .input:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Button System */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-xs);
            padding: var(--space-sm) var(--space-md);
            border: none;
            border-radius: var(--radius-md);
            font-size: var(--text-sm);
            font-weight: 600;
            text-decoration: none;
            cursor: pointer;
            transition: var(--transition);
            user-select: none;
            min-height: 44px;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .btn:active {
            transform: translateY(0);
            box-shadow: var(--shadow-sm);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-primary {
            background: var(--color-action);
            color: white;
        }

        .btn-primary:hover {
            background: var(--color-action-hover);
            box-shadow: var(--shadow-action);
        }

        .btn-secondary {
            background: var(--color-secondary);
            color: white;
        }

        .btn-secondary:hover {
            background: var(--color-secondary-hover);
        }

        .btn-success {
            background: var(--color-success);
            color: white;
        }

        .btn-warning {
            background: var(--color-warning);
            color: white;
        }

        .btn-info {
            background: var(--color-info);
            color: white;
        }

        /* Button Group */
        .button-group {
            display: flex;
            gap: var(--space-sm);
            margin-top: var(--space-md);
            justify-content: center;
            flex-wrap: wrap;
        }

        /* Video Container - Centered */
        .video-container {
            position: relative;
            margin: var(--space-xl) auto var(--space-lg) auto;
            overflow: hidden;
            border-radius: var(--radius-xl);
            background: var(--color-bg-card);
            border: 1px solid var(--color-border);
            max-width: 1200px;
            box-shadow: var(--shadow-md);
        }

        .main-video-box {
            width: 100%;
            background-color: #000;
            border-radius: var(--radius-lg);
            overflow: hidden;
        }

        .video-title {
            padding: 2.5px var(--space-sm);
            font-weight: 600;
            background: rgba(194, 41, 31, 0.9);
            border-bottom: 1px solid var(--color-border);
            color: white;
            font-size: var(--text-base);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .video-title-text {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        /* Toggle Switch for Settings - Recorder 스타일 적용 */
        .toggle-switch {
            margin-left: auto;
            display: flex;
            align-items: center;
        }

        .toggle-switch input {
            display: none;
        }

        .toggle-slider {
            position: relative;
            width: 40px;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 4px;
        }

        .toggle-slider:before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transition: var(--transition);
        }

        .toggle-text-on,
        .toggle-text-off {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 8px;
            font-weight: bold;
            color: white;
            transition: var(--transition);
            white-space: nowrap;
        }

        .toggle-text-on {
            left: 6px;
            opacity: 0;
        }

        .toggle-text-off {
            right: 6px;
            opacity: 1;
        }

        .toggle-switch input:checked + .toggle-slider .toggle-text-on {
            opacity: 1;
        }

        .toggle-switch input:checked + .toggle-slider .toggle-text-off {
            opacity: 0;
        }

        .toggle-switch input:checked + .toggle-slider {
            background: var(--color-action);
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }

        #reaction-youtube-container {
            width: 100%;
            aspect-ratio: 16 / 9;
            background-color: #000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #reaction-youtube-container iframe {
            width: 100% !important;
            height: 100% !important;
            object-fit: contain;
        }

        /* Overlay styles */
        #youtube-container {
            position: absolute;
            background-color: #000;
            border-radius: var(--radius-md);
            overflow: hidden;
            z-index: 10;
            box-shadow: var(--shadow-lg);
            width: 50%;
            transition: all 0.3s ease;
            aspect-ratio: 16 / 9;
        }

        #youtube-container iframe {
            width: 100% !important;
            height: 100% !important;
        }

        #youtube-container.overlay-top-right {
            top: calc(var(--space-md) + 20px);
            right: var(--space-md);
        }

        #youtube-container.overlay-top-left {
            top: calc(var(--space-md) + 20px);
            left: var(--space-md);
        }

        #youtube-container.overlay-bottom-right {
            bottom: 60px;
            right: var(--space-md);
        }

        #youtube-container.overlay-bottom-left {
            bottom: 60px;
            left: var(--space-md);
        }

        /* Quick Playback Controls - Right below video */
        .quick-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-sm);
            flex-wrap: wrap;
            margin-top: var(--space-xs);
        }

        .quick-controls .btn {
            min-width: 80px;
            padding: 6px 12px;
            font-size: var(--text-sm);
            font-weight: 600;
            border-radius: var(--radius-md);
            transition: all 0.15s ease;
            border: 1px solid rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(8px);
            position: relative;
            overflow: hidden;
        }

        .quick-controls .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .quick-controls .btn:hover::before {
            left: 100%;
        }

        .quick-controls .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .quick-controls .btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .quick-controls .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .quick-controls .btn:disabled::before {
            display: none;
        }

        /* Help button specific style */
        .quick-controls .btn-info {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #ffc107;
            color: var(--color-text-main);
        }

        .quick-controls .btn-info:hover {
            background: rgba(255, 193, 7, 0.1);
            border-color: #ffd54f;
            color: #ffc107;
        }

        /* Resync button in quick controls */
        .quick-controls .inline-btn {
            align-self: flex-end;
            margin-top: 5px;
        }

        /* Beta Version Notice */
        .beta-notice {
            background: rgba(255, 193, 7, 0.08);
            border: 1px solid rgba(255, 193, 7, 0.2);
            border-radius: var(--radius-lg);
            margin-top: var(--space-md);
            padding: var(--space-md) var(--space-lg);
            backdrop-filter: blur(15px);
            box-shadow: var(--shadow-sm);
        }

        .beta-notice-content {
            display: flex;
            align-items: flex-start;
            gap: var(--space-md);
        }

        .beta-notice-icon {
            font-size: var(--text-xl);
            margin-top: 2px;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3));
        }

        .beta-notice-text {
            color: var(--color-text-main);
            font-size: var(--text-sm);
            line-height: 1.6;
            font-weight: 400;
        }

        .beta-notice-text strong {
            color: #ffc107;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        /* Help FAQ Styles */
        .help-faq {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: var(--radius-xl);
            margin-top: var(--space-md);
            box-shadow: var(--shadow-lg);
            backdrop-filter: blur(15px);
            max-height: 70vh;
            overflow-y: auto;
        }

        .help-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-xs) var(--space-sm);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(255, 255, 255, 0.05);
            border-radius: var(--radius-xl) var(--radius-xl) 0 0;
        }

        .help-header h3 {
            margin: 0;
            color: white;
            font-size: var(--text-base);
            font-weight: 700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .help-close-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: var(--color-text-sub);
            font-size: var(--text-xl);
            cursor: pointer;
            padding: var(--space-xs);
            border-radius: var(--radius-sm);
            transition: var(--transition);
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .help-close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: var(--color-text-main);
            transform: scale(1.1);
        }

        .faq-content {
            padding: var(--space-sm);
        }

        .faq-content:first-child {
            padding-top: 0;
        }

        .faq-content .faq-section:first-child {
            padding-top: 0 !important;
            margin-top: 0 !important;
        }

        .faq-content .faq-section:first-child h4 {
            margin-top: var(--space-sm) !important;
            padding-top: var(--space-sm) !important;
        }

        .faq-content .faq-section:first-child .faq-item:first-child {
            margin-top: 0 !important;
            padding-top: 0 !important;
        }

        .faq-section {
            margin-bottom: var(--space-xs);
            padding: var(--space-xs);
            background: rgba(255, 255, 255, 0.03);
            border-radius: var(--radius-md);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .faq-section:first-child {
            padding-top: 0 !important;
            margin-top: 0 !important;
        }

        .faq-section:first-child .faq-item:first-child {
            margin-top: 0 !important;
            padding-top: 0 !important;
        }

        .faq-content .faq-section:first-child {
            padding-top: 0 !important;
            margin-top: 0 !important;
        }

        .faq-content .faq-section:first-child .faq-item:first-child {
            margin-top: 0 !important;
            padding-top: 0 !important;
        }

        .faq-section:last-child {
            margin-bottom: 0;
        }

        .faq-section h4 {
            color: white;
            font-size: var(--text-base);
            margin-bottom: var(--space-xs);
            margin-top: 0;
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            font-weight: 700;
            padding: var(--space-xs) var(--space-sm);
            background: rgba(255, 193, 7, 0.1);
            border-radius: var(--radius-sm);
            border: 1px solid rgba(255, 193, 7, 0.2);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .faq-section p {
            color: var(--color-text-main);
            font-size: var(--text-sm);
            line-height: 1.4;
            margin-bottom: var(--space-xs);
            font-weight: 400;
        }

        .faq-section ul {
            color: var(--color-text-main);
            font-size: var(--text-sm);
            line-height: 1.4;
            margin-left: var(--space-sm);
            margin-bottom: var(--space-xs);
        }

        .faq-section li {
            margin-bottom: var(--space-xs);
            padding-left: var(--space-xs);
        }

        .faq-item {
            margin-bottom: var(--space-xs);
            padding: var(--space-xs);
            background: rgba(255, 255, 255, 0.05);
            border-radius: var(--radius-sm);
            border-left: 3px solid var(--color-action);
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .faq-item:last-child {
            margin-bottom: 0;
        }

        .faq-item h5 {
            color: #ffd54f;
            font-size: var(--text-sm);
            margin-bottom: var(--space-xs);
            font-weight: 600;
            text-shadow: 0 1px 1px rgba(0, 0, 0, 0.3);
        }

        .inline-btn {
            background: linear-gradient(135deg, #ffc107, #ffd54f);
            color: #333;
            border: none;
            padding: 3px 8px;
            border-radius: var(--radius-sm);
            font-size: 0.7em;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            box-shadow: var(--shadow-sm);
            position: relative;
        }

        .inline-btn:hover {
            background: linear-gradient(135deg, #ffd54f, #ffc107);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .inline-btn:hover::after {
            content: "Beta - Not perfect yet";
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7em;
            white-space: nowrap;
            z-index: 9999;
        }

        /* New compact issue box styles */
        .compact-issue-box {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--radius-sm);
            padding: var(--space-sm);
            margin-bottom: var(--space-sm);
            border-left: 3px solid var(--color-action);
        }

        .compact-issue-box h5 {
            color: #ffd54f;
            font-size: var(--text-sm);
            margin: 0 0 var(--space-xs) 0;
            font-weight: 600;
            text-shadow: 0 1px 1px rgba(0, 0, 0, 0.3);
        }

        .compact-issue-box p {
            color: var(--color-text-main);
            font-size: var(--text-sm);
            line-height: 1.4;
            margin: 0 0 var(--space-xs) 0;
            font-weight: 400;
        }

        .compact-issue-box ul {
            color: var(--color-text-main);
            font-size: var(--text-sm);
            line-height: 1.4;
            margin: 0 0 0 var(--space-sm);
            padding: 0;
        }

        .compact-issue-box li {
            margin-bottom: 4px;
            padding-left: var(--space-xs);
        }

        /* Controls Grid */
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: var(--space-lg);
            margin-bottom: var(--space-lg);
        }

        /* Source Selector */
        .source-selector {
            display: flex;
            gap: var(--space-md);
            margin-bottom: var(--space-md);
            background: var(--color-bg-input);
            padding: var(--space-sm);
            border-radius: var(--radius-md);
        }

        .source-selector label {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: var(--space-xs) var(--space-sm);
            border-radius: var(--radius-sm);
            transition: var(--transition);
            font-weight: 500;
        }

        .source-selector label:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .source-selector input[type="radio"] {
            margin-right: var(--space-xs);
            accent-color: var(--color-action);
        }

        /* Slider System */
        .slider-container {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            margin-top: var(--space-sm);
        }

        .slider-container input[type="range"] {
            flex-grow: 1;
            height: 8px;
            background: var(--color-secondary);
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
        }

        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--color-action);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: var(--shadow-sm);
        }

        .slider-value {
            min-width: 60px;
            text-align: center;
            font-weight: bold;
            color: var(--color-action);
            font-size: var(--text-lg);
        }

        /* Status and Messages */
        .status {
            margin-top: var(--space-md);
            font-style: italic;
            color: var(--color-text-sub);
            text-align: center;
            padding: var(--space-sm);
            background: var(--color-bg-input);
            border-radius: var(--radius-md);
        }

        .message {
            padding: var(--space-md);
            margin-top: var(--space-md);
            border-radius: var(--radius-md);
            display: none;
            font-weight: 500;
        }

        .message.error {
            background: rgba(244, 67, 54, 0.1);
            border: 1px solid var(--color-error);
            color: var(--color-error);
        }

        .message.success {
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid var(--color-success);
            color: var(--color-success);
        }

        .message.info {
            background: rgba(33, 150, 243, 0.1);
            border: 1px solid var(--color-info);
            color: var(--color-info);
        }

        /* Debug Info */
        .debug-info {
            background: var(--color-bg-card);
            padding: var(--space-lg);
            border-radius: var(--radius-lg);
            margin-bottom: var(--space-lg);
            border: 1px solid var(--color-border);
        }

        .debug-info h3 {
            margin-top: 0;
            margin-bottom: var(--space-md);
            color: var(--color-text-main);
            font-size: var(--text-lg);
        }

        #debug-content {
            font-family: 'Courier New', monospace;
            font-size: var(--text-sm);
            max-height: 300px;
            overflow-y: auto;
            background: var(--color-bg-input);
            padding: var(--space-md);
            border-radius: var(--radius-md);
            border: 1px solid var(--color-border);
            color: var(--color-text-sub);
            line-height: 1.4;
        }

        /* Footer */
        footer {
            text-align: center;
            margin-top: var(--space-xl);
            padding-top: var(--space-lg);
            border-top: 1px solid var(--color-border);
            font-size: var(--text-sm);
            color: var(--color-text-muted);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: var(--space-md);
            }
            
            .header-content {
                flex-direction: column;
                gap: var(--space-md);
            }
            
            .controls-grid {
                grid-template-columns: 1fr;
                gap: var(--space-md);
            }
            
            .button-group {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
                justify-content: center;
            }
            
            #reaction-youtube-container, 
            #reaction-youtube-container iframe {
                min-height: 400px;
            }
            
            .source-selector {
                flex-direction: column;
                gap: var(--space-sm);
            }

            .floating-controls {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                top: auto;
                transform: none;
                border-radius: var(--radius-lg) var(--radius-lg) 0 0;
                max-width: none;
                max-height: 60vh;
            }

            .floating-toggle {
                position: absolute;
                top: -40px;
                left: 50%;
                transform: translateX(-50%);
                border-radius: var(--radius-md) var(--radius-md) 0 0;
            }

            .floating-controls.collapsed {
                transform: translateY(calc(100% - 50px));
            }

            .floating-controls.collapsed .floating-toggle {
                border-radius: var(--radius-md);
            }

            .quick-controls {
                flex-direction: column;
            }

            .quick-controls .btn {
                width: 100%;
            }

            .status-bar {
                flex-direction: column;
                align-items: stretch;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <div class="header-content">
                <div class="header-center">
                    <h1>
                        <div class="header-logo"></div>
                        Multi-Window-Viewer
                        <span class="beta-tag">Beta</span>
                        <button class="info-icon" id="infoIcon" title="Learn more about this solution">i</button>
                        <a href="/studio.html" class="create-own-btn" title="Create your own reaction video">Create My Own</a>
                        <div class="apple-tooltip" id="appleTooltip">
                            <div class="apple-tooltip-header">
                                <h3 class="apple-tooltip-title">VirtuEDIT Technology</h3>
                                <div class="apple-tooltip-subtitle">US Patent Registered • First ever IP Solution for Video Platforms</div>
                            </div>
                            
                            <div class="apple-tooltip-section">
                                <p class="apple-tooltip-section-content" style="line-height: 1.2;">
                                    Millisecond precision synchronization.<br>
                                    Real YouTube videos played simultaneously.
                                </p>
                            </div>

                            <div class="apple-tooltip-highlight">
                                <div class="apple-tooltip-highlight-title">Everyone Wins</div>
                                <div class="apple-tooltip-highlight-content" style="color: #fff; font-size: 14px;">
                                    <strong style="font-weight: 600;">Reactors:</strong> Monetize without copyright fears<br>
                                    <strong style="font-weight: 600;">Artists:</strong> Get views & revenue from every reaction<br>
                                    <strong style="font-weight: 600;">Platforms:</strong> Revenue from previously non-monetizable content<br>
                                    <strong style="font-weight: 600;">Viewers:</strong> Perfect synchronized reaction experiences
                                </div>
                            </div>

                            <div class="apple-tooltip-section">
                                <p class="apple-tooltip-section-content">
                                    Official YouTube players only. All copyright protections intact.
                                </p>
                            </div>
                        </div>
                    </h1>

            </div>
        </header>

        <!-- Video Player Section - Now at the top -->
        <div class="video-container">
            <div class="main-video-box">
                <div class="video-title">
                    <div class="video-title-text">
                        <span>🎬</span>
                        <span>Reaction Video</span>
                </div>
                    <div style="display: flex; align-items: center; gap: var(--space-sm); background: rgba(255, 255, 255, 0.1); padding: 4px 8px; border-radius: var(--radius-sm); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2);">
                        <span style="font-size: var(--text-sm); color: rgba(255, 255, 255, 0.9);">Overlay Custom Settings</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="overlayToggleBtn">
                            <span class="toggle-slider">
                                <span class="toggle-text-on">ON</span>
                                <span class="toggle-text-off">OFF</span>
                            </span>
                        </label>
                    </div>
                </div>
                <video id="reaction-player" controls style="display: none;"></video>
                <div id="reaction-youtube-container" style="display: block;"></div>
            </div>
            
            <div id="youtube-container" class="overlay-top-right">
                <div id="youtube-player"></div>
            </div>
        </div>

                        <!-- Quick Playback Controls - Right below video -->
        <div class="quick-controls">
            <button id="play-btn" class="btn btn-primary" disabled>Play</button>
            <button id="pause-btn" class="btn btn-secondary" disabled>Pause</button>
            <button id="stop-btn" class="btn btn-secondary" disabled>Stop</button>
            <button id="restart-btn" class="btn btn-secondary" disabled>Restart</button>
            <button id="help-btn" class="btn btn-info">Help</button>
            <button id="resyncBtn" class="inline-btn">Resync</button>
        </div>

        <!-- Beta Version Notice -->
        <div class="beta-notice">
            <div class="beta-notice-content">
                <span class="beta-notice-icon">⚠️</span>
                <div class="beta-notice-text">
                    <strong>Beta Version</strong><br>
                    Continuous playback is stable. Jumping to other points works but may occasionally cause unexpected issues.<br>
                    If you experience problems or want more information, please press the Help button.
                </div>
            </div>
        </div>

        <!-- Floating Overlay Settings Panel -->
        <div class="overlay-settings-panel" id="overlaySettingsPanel">
            <div class="overlay-settings-header">
                <h3 class="overlay-settings-title">
                    <span>⚙️</span>
                    <span>Overlay Settings</span>
                </h3>
            </div>
            
            <div class="compact-controls">
                <div class="input-group">
                    <label for="overlay-position" class="input-label">Overlay Position</label>
                    <select id="overlay-position" class="input">
                    <option value="top-right">Top Right</option>
                    <option value="top-left">Top Left</option>
                    <option value="bottom-right">Bottom Right</option>
                    <option value="bottom-left">Bottom Left</option>
                </select>
            </div>
                
                <div class="input-group">
                    <label for="overlay-size" class="input-label">Overlay Size</label>
                <div class="slider-container">
                        <input type="range" id="overlay-size" min="10" max="60" value="50">
                    <span id="overlay-size-value" class="slider-value">50%</span>
                </div>
            </div>
                
                <div class="input-group">
                    <label for="youtube-volume" class="input-label">Original Video Volume</label>
                <div class="slider-container">
                    <input type="range" id="youtube-volume" min="0" max="100" value="100">
                    <span id="youtube-volume-value" class="slider-value">100%</span>
                </div>
            </div>

                <div class="input-group">
                    <label class="input-label">Overlay Visibility</label>
                    <button id="toggle-overlay" class="btn btn-secondary" disabled>Hide Overlay</button>
            </div>
            </div>
        </div>

                <!-- Message Display -->
        <div class="message" id="message"></div>
        

        
        <!-- Help FAQ -->
        <div class="help-faq" id="helpFaq" style="display: none;">
            <div class="help-header">
                <h3>❓ Help & FAQ</h3>
                <button class="help-close-btn" id="helpCloseBtn">×</button>
            </div>
            
            <div class="faq-content">
                <div class="faq-section">
                    <h4>⚠️ Common Issues & Solutions</h4>
                    <div class="compact-issue-box">
                        <h5>Jump to timestamp doesn't work properly</h5>
                        <p><strong>Solutions:</strong></p>
                        <ul>
                            <li>Use the <button class="inline-btn" id="resyncBtn">Resync</button> button to reset synchronization</li>
                            <li>Start playback from slightly before the start and end of the sync point (timestamp)</li>
                            <li>Try restarting from the beginning</li>
                            <li>Avoid interacting with the original video for smooth timestamp control</li>
                        </ul>
                    </div>

                    <div class="compact-issue-box">
                        <h5>Playback speed issues</h5>
                        <p>Beta version may have issues with playback speed changes. Try using normal speed (1x) for best results.</p>
                    </div>
                </div>
        
                <div class="faq-section">
                    <h4>🎬 About YouTube Player</h4>
                    <p>We simply display the official YouTube player window as-is to ensure legal and ethical compliance. This means:</p>
                    <ul>
                        <li>Ads and recommended videos may appear (YouTube's standard behavior)</li>
                        <li>Original video is clickable but we recommend avoiding interaction for smooth timestamp control</li>
                        <li>All YouTube terms and copyright protections remain fully intact, ensuring no risk of disputes.</li>
                    </ul>
                </div>
            </div>
        </div>

        <footer>
            <p>This application is designed to watch reaction videos without copyright infringement.</p>
        </footer>
    </div>

    <!-- YouTube API -->
    <script src="https://www.youtube.com/iframe_api"></script>
    <script>
    // Fixed Viewer JavaScript - Completely Redesigned Synchronization Logic with Enhanced Event Detection
    // Version 7: Fixed YouTube-YouTube mode synchronization and player creation with improved UI and default YouTube URL mode

    // Global variables
    let youtubePlayer = null;
    let reactionPlayer = null;
    let timestampData = null;
    let syncInterval = null; // Interval for file mode sync
    let isPlaying = false;
    let youtubeReady = false;
    let overlayPosition = 'top-right'; // Default overlay position
    let overlaySize = 50; // Default overlay size (%) - Changed from 20% to 50%
    let reactionSource = 'youtube'; // 'file' or 'youtube' - Changed default to 'youtube'
    let reactionYoutubePlayer = null;
    let isOverlayVisible = true; // Overlay visibility
    let youtubeVolume = 100; // YouTube volume (0-100)

    // Critical timestamp variables
    let youtubeStarted = false; // Flag to track if YouTube video has started
    let firstSyncPoint = null; // Store the first sync point
    let waitingForFirstSync = false; // Flag to indicate we're waiting for first sync point
    let youtubePlayerCreated = false; // Flag to track if YouTube player has been created
    let youtubeVideoId = null; // Store YouTube video ID for delayed creation
    let youtubeFirstPlayTime = null; // Store the time when YouTube video was first played
    let lastProcessedPauseTime = -1; // Track the last processed pause event time
    let lastProcessedPlayTime = -1; // Track the last processed play event time
    let youtubePaused = false; // Track if YouTube is paused by timestamp
    let lastSyncTime = 0; // Track the last time we synchronized videos
    let debugInfo = []; // Store debug information

    // New variables for improved synchronization
    let pauseEvents = []; // Store all pause events for quick lookup
    let playEvents = []; // Store all play events for quick lookup
    let currentSyncPoint = null; // Current active sync point
    let nextPauseTime = null; // Next pause time in reaction video timeline
    let nextPlayTime = null; // Next play time in reaction video timeline
    let syncMode = 'precise'; // 'precise' or 'relaxed' synchronization mode
    let missedEventCheckEnabled = true; // Enable checking for missed events
    let eventDetectionWindow = 0.5; // Increased event detection window (seconds)
    let lastReactionTime = 0; // Last processed reaction time (for file mode)

    // YouTube-YouTube synchronization variables
    let youtubeYoutubeMode = true; // Flag to indicate if both videos are YouTube - Changed default to true
    let reactionYoutubeReady = false; // Flag to track if reaction YouTube player is ready
    let reactionYoutubeCurrentTime = 0; // Current time of reaction YouTube player
    let lastReactionYoutubeTime = 0; // Last time of reaction YouTube player
    let youtubeYoutubeSyncInterval = null; // Interval for YouTube-YouTube synchronization
    let reactionYoutubeStateChangeTime = 0; // Time of last state change in reaction YouTube player
    let youtubeYoutubeSyncEnabled = true; // Enable YouTube-YouTube synchronization
    let youtubeYoutubeSyncFrequency = 200; // Frequency of YouTube-YouTube synchronization in ms (Increased frequency)
    let youtubeYoutubeSyncThreshold = 0.3; // Threshold for YouTube-YouTube synchronization in seconds
    let reactionYoutubeState = -1; // Current state of reaction YouTube player

    // YouTube API callback
    function onYouTubeIframeAPIReady() {
        youtubeReady = true;
        console.log("YouTube API is ready");
    }

    // DOM loaded event
    document.addEventListener('DOMContentLoaded', function() {
        // Overlay settings panel controls
        const overlayToggleBtn = document.getElementById('overlayToggleBtn');
        const overlaySettingsPanel = document.getElementById('overlaySettingsPanel');
        
        if (overlayToggleBtn && overlaySettingsPanel) {
            overlayToggleBtn.addEventListener('change', function() {
                if (this.checked) {
                    overlaySettingsPanel.classList.add('show');
                } else {
                    overlaySettingsPanel.classList.remove('show');
                }
            });
        }

        // Apple-style tooltip controls - Hover based
        const infoIcon = document.getElementById('infoIcon');
        const appleTooltip = document.getElementById('appleTooltip');
        
        if (infoIcon && appleTooltip) {
            // Show tooltip on hover
            infoIcon.addEventListener('mouseenter', function() {
                appleTooltip.classList.add('show');
            });
            
            // Hide tooltip when mouse leaves
            infoIcon.addEventListener('mouseleave', function() {
                appleTooltip.classList.remove('show');
            });
            
            // Also hide tooltip when mouse leaves the tooltip itself
            appleTooltip.addEventListener('mouseleave', function() {
                appleTooltip.classList.remove('show');
            });
        }
        // Check for VE URL in the URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const veId = urlParams.get('ve');
        
        if (veId) {
            console.log("VE URL detected:", veId);
            addDebugMessage(`VE URL detected: ${veId}`);
            
            // Load VE URL data from server
            loadVEUrlFromServer(veId);
        }
        
        // Element references
        const timestampFileInput = document.getElementById('timestamp-file');
        const reactionVideoInput = document.getElementById('reaction-video');
        const reactionUrlInput = document.getElementById('reaction-url');
        const youtubeUrlInput = document.getElementById('youtube-url');
        const loadBtn = document.getElementById('load-btn');
        const playBtn = document.getElementById('play-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const stopBtn = document.getElementById('stop-btn');
        const restartBtn = document.getElementById('restart-btn');
        const helpBtn = document.getElementById('help-btn');
        const helpFaq = document.getElementById('helpFaq');
        const helpCloseBtn = document.getElementById('helpCloseBtn');
        const resyncBtn = document.getElementById('resyncBtn');
        const messageElement = document.getElementById('message');
        const overlayPositionSelect = document.getElementById('overlay-position');
        const overlaySizeSlider = document.getElementById('overlay-size');
        const overlaySizeValue = document.getElementById('overlay-size-value');
        const sourceTypeRadios = document.querySelectorAll('input[name="reaction-source"]');
        const toggleOverlayBtn = document.getElementById('toggle-overlay');
        const youtubeVolumeSlider = document.getElementById('youtube-volume');
        const youtubeVolumeValue = document.getElementById('youtube-volume-value');
        
        reactionPlayer = document.getElementById('reaction-player');
        const reactionYoutubeContainer = document.getElementById('reaction-youtube-container');
        const youtubeContainer = document.getElementById('youtube-container');
        
        // Initially hide YouTube container until first sync point
        youtubeContainer.style.display = 'none';

        // Source type change event
        sourceTypeRadios.forEach(radio => {
            radio.addEventListener('change', function() {
                reactionSource = this.value;
                if (reactionSource === 'file') {
                    document.getElementById('file-source-container').style.display = 'block';
                    document.getElementById('youtube-source-container').style.display = 'none';
                    reactionPlayer.style.display = 'block';
                    reactionYoutubeContainer.style.display = 'none';
                    youtubeYoutubeMode = false;
                } else {
                    document.getElementById('file-source-container').style.display = 'none';
                    document.getElementById('youtube-source-container').style.display = 'block';
                    reactionPlayer.style.display = 'none';
                    reactionYoutubeContainer.style.display = 'block';
                    youtubeYoutubeMode = true;
                }
            });
        });

        // Overlay position change event
        overlayPositionSelect.addEventListener('change', function() {
            overlayPosition = this.value;
            updateOverlayPosition();
        });

        // Overlay size change event
        overlaySizeSlider.addEventListener('input', function() {
            overlaySize = parseInt(this.value);
            overlaySizeValue.textContent = overlaySize + '%';
            updateOverlaySize();
        });
        
        // Overlay toggle button event
        toggleOverlayBtn.addEventListener('click', function() {
            isOverlayVisible = !isOverlayVisible;
            updateOverlayVisibility();
            this.textContent = isOverlayVisible ? 'Hide Overlay' : 'Show Overlay';
        });
        
        // YouTube volume control event
        youtubeVolumeSlider.addEventListener('input', function() {
            youtubeVolume = parseInt(this.value);
            youtubeVolumeValue.textContent = youtubeVolume + '%';
            updateYoutubeVolume();
        });

        // Help button event
        if (helpBtn && helpFaq) {
            helpBtn.addEventListener('click', function() {
                // Show FAQ if hidden
                if (helpFaq.style.display === 'none') {
                    helpFaq.style.display = 'block';
                    
                    // Smooth scroll to FAQ
                    setTimeout(() => {
                        helpFaq.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'start',
                            inline: 'nearest'
                        });
                    }, 100);
                } else {
                    helpFaq.style.display = 'none';
                }
            });
        }

        // Help close button event
        if (helpCloseBtn && helpFaq) {
            helpCloseBtn.addEventListener('click', function() {
                helpFaq.style.display = 'none';
                
                // Scroll back to top smoothly
                window.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            });
        }

        // Inline resync button event
        if (resyncBtn) {
            resyncBtn.addEventListener('click', function() {
                resyncVideos();
            });
        }

        // Reaction player setup (HTML5 video)
        reactionPlayer.addEventListener('loadedmetadata', function() {
            console.log('Status: Reaction Video Loaded');
        });
        
        // Reaction video ended event (HTML5 video)
        reactionPlayer.addEventListener('ended', function() {
            stopSynchronizedPlayback();
        });
        
        // Reaction video timeupdate event (HTML5 video) - ONLY for file mode sync
        reactionPlayer.addEventListener('timeupdate', function() {
            // Only run this logic if in file mode
            if (!youtubeYoutubeMode) {
                const currentTime = reactionPlayer.currentTime;
                handleSynchronization(currentTime);
            }
        });

        // Timestamp file load
        if (timestampFileInput) {
            timestampFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    timestampData = JSON.parse(e.target.result);
                    
                    // ENHANCED: Pre-process all events for quick lookup
                    if (timestampData.sync_points && timestampData.sync_points.length > 0) {
                        // Clear existing events
                        pauseEvents = [];
                        playEvents = [];
                        debugInfo = [];
                        
                        // Process all events
                        timestampData.sync_points.forEach(point => {
                            // Store first play time
                            if (point.youtube_first_play_time !== undefined && point.youtube_first_play_time !== null) {
                                youtubeFirstPlayTime = point.youtube_first_play_time;
                            }
                            
                            // Categorize events
                            if (point.event === 'youtube_pause') {
                                pauseEvents.push(point);
                            } else if (point.event === 'youtube_play') {
                                playEvents.push(point);
                            }
                        });
                        
                        // Sort events by reaction_time
                        pauseEvents.sort((a, b) => a.reaction_time - b.reaction_time);
                        playEvents.sort((a, b) => a.reaction_time - b.reaction_time);
                        
                        // Find first sync point (first play event)
                        firstSyncPoint = playEvents.length > 0 ? playEvents[0] : null;
                        
                        if (firstSyncPoint) {
                            console.log("First sync point loaded:", firstSyncPoint);
                            console.log("All pause events:", pauseEvents);
                            console.log("All play events:", playEvents);
                            
                            addDebugMessage("Timestamp file loaded successfully");
                            addDebugMessage(`Found ${playEvents.length} play events and ${pauseEvents.length} pause events`);
                            
                            // Log all events for debugging
                            playEvents.forEach(event => {
                                addDebugMessage(`Play event at ${event.reaction_time.toFixed(2)}s -> YouTube ${event.relative_youtube_time.toFixed(2)}s`);
                            });
                            
                            pauseEvents.forEach(event => {
                                addDebugMessage(`Pause event at ${event.reaction_time.toFixed(2)}s -> YouTube ${event.relative_youtube_time.toFixed(2)}s`);
                            });
                        }
                    }
                    
                    showMessage('Timestamp file loaded successfully.', 'success');
                    console.log('Status: Timestamp Loaded');
                    updateDebugDisplay();
                } catch (error) {
                    showMessage('Timestamp file parsing error: ' + error.message, 'error');
                }
            };
            reader.onerror = function() {
                showMessage('Error reading file.', 'error');
            };
            reader.readAsText(file);
            });
        }

        // Reaction video load (file)
        if (reactionVideoInput) {
            reactionVideoInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const url = URL.createObjectURL(file);
            reactionPlayer.src = url;
            showMessage('Reaction video loaded.', 'success');
            });
        }

        // Load button click
        if (loadBtn) {
            loadBtn.addEventListener('click', function() {
            // Check if we're in VE server mode
            const urlParams = new URLSearchParams(window.location.search);
            const veId = urlParams.get('ve');
            
            if (veId) {
                // In VE server mode, load button should just re-trigger auto-load
                console.log("🔄 Re-triggering auto-load in VE server mode");
                addDebugMessage("🔄 Re-triggering auto-load in VE server mode");
                autoLoadForVEServer();
                return;
            }
            
            // Normal load logic for manual mode
            const youtubeUrl = youtubeUrlInput.value.trim();
            
            if (!timestampData) {
                showMessage('Please load timestamp file first.', 'error');
                return;
            }
            
            if (reactionSource === 'file' && !reactionPlayer.src) {
                showMessage('Please select reaction video first.', 'error');
                return;
            }
            
            if (reactionSource === 'youtube') {
                const reactionUrl = reactionUrlInput.value.trim();
                if (!reactionUrl) {
                    showMessage('Please enter reaction video URL.', 'error');
                    return;
                }
                
                // Extract reaction video YouTube ID
                const reactionVideoId = extractYouTubeVideoId(reactionUrl);
                if (!reactionVideoId) {
                    showMessage('Invalid reaction video YouTube URL.', 'error');
                    return;
                }
                
                // Remove existing reaction YouTube player
                if (reactionYoutubePlayer) {
                    reactionYoutubePlayer.destroy();
                    reactionYoutubePlayer = null;
                }
                
                // Set YouTube-YouTube mode flag
                youtubeYoutubeMode = true;
                reactionYoutubeReady = false;
                
                // Create new reaction YouTube player with improved height
                reactionYoutubePlayer = new YT.Player('reaction-youtube-container', {
                    height: '540', // 1.5배 높이 증가 (기본 360px의 1.5배)
                    width: '100%',
                    videoId: reactionVideoId,
                    playerVars: {
                        'playsinline': 1,
                        'controls': 1,
                        'autoplay': 0,
                        'rel': 0
                    },
                    events: {
                        'onReady': onReactionPlayerReady,
                        'onStateChange': onReactionPlayerStateChange
                    }
                });
                
                addDebugMessage(`Created reaction YouTube player with video ID: ${reactionVideoId}`);
            } else {
                // Set YouTube-YouTube mode flag to false for file mode
                youtubeYoutubeMode = false;
            }
            
            if (!youtubeUrl) {
                showMessage('Please enter YouTube URL.', 'error');
                return;
            }

            // Extract YouTube video ID
            youtubeVideoId = extractYouTubeVideoId(youtubeUrl);
            if (!youtubeVideoId) {
                showMessage('Invalid YouTube URL.', 'error');
                return;
            }

            // CRITICAL CHANGE: We don't create the YouTube player here anymore
            // We'll create it only when we reach the first sync point
            
            // If there was a previous player, destroy it
            if (youtubePlayer) {
                youtubePlayer.destroy();
                youtubePlayer = null;
                youtubePlayerCreated = false;
            }
            
            // Hide YouTube container until first sync point
            document.getElementById('youtube-container').style.display = 'none';

            console.log('Status: Ready to Play');
            enableControls(true);
            
            // Reset YouTube started flag
            youtubeStarted = false;
            waitingForFirstSync = false;
            
            // Reset tracking variables
            lastProcessedPauseTime = -1;
            lastProcessedPlayTime = -1;
            youtubePaused = false;
            currentSyncPoint = null;
            nextPauseTime = null;
            nextPlayTime = null;
            lastReactionTime = 0;
            reactionYoutubeCurrentTime = 0;
            lastReactionYoutubeTime = 0;
            
            // Clear debug info
            debugInfo = [];
            addDebugMessage("Ready to play. Click Play to start.");
            updateDebugDisplay();
            
            showMessage('All media loaded. Click Play to start.', 'success');
            });
        }

        // Play button click
        if (playBtn) {
            playBtn.addEventListener('click', function() {
            // Check if we're in VE server mode
            const urlParams = new URLSearchParams(window.location.search);
            const veId = urlParams.get('ve');
            
            if (veId) {
                // In VE server mode, check if data is loaded
                if (!youtubeVideoId) {
                    showMessage('Please load videos first.', 'error');
                    return;
                }
                
                if (reactionSource === 'file' && !reactionPlayer.src) {
                    showMessage('Please select reaction video first.', 'error');
                    return;
                }
                
                if (reactionSource === 'youtube' && !reactionYoutubePlayer) {
                    showMessage('Please load reaction video URL first.', 'error');
                    return;
                }
            } else {
                // Normal mode checks
                if (!youtubeVideoId) {
                    showMessage('Please load videos first.', 'error');
                    return;
                }
                
                if (reactionSource === 'file' && !reactionPlayer.src) {
                    showMessage('Please select reaction video first.', 'error');
                    return;
                }
                
                if (reactionSource === 'youtube' && !reactionYoutubePlayer) {
                    showMessage('Please load reaction video URL first.', 'error');
                    return;
                }
            }
            
            startSynchronizedPlayback();
            });
        }

        // Pause button click
        if (pauseBtn) {
            pauseBtn.addEventListener('click', function() {
                pauseSynchronizedPlayback();
            });
        }

        // Stop button click
        if (stopBtn) {
            stopBtn.addEventListener('click', function() {
                stopSynchronizedPlayback();
            });
        }

        // Restart button click
        if (restartBtn) {
            restartBtn.addEventListener('click', function() {
                restartSynchronizedPlayback();
            });
        }

        // Resync function for inline button
        function resyncVideos() {
            console.log("🔄 Resync: Resetting synchronization");
            addDebugMessage("🔄 Resync: Resetting synchronization");
            
            // Reset sync state
            youtubeStarted = false;
            waitingForFirstSync = false;
            currentSyncPoint = null;
            nextPauseTime = null;
            nextPlayTime = null;
            lastProcessedPauseTime = -1;
            lastProcessedPlayTime = -1;
            
            // If currently playing, restart playback
            if (isPlaying) {
                pauseSynchronizedPlayback();
                setTimeout(() => {
                    startSynchronizedPlayback();
                    showMessage('Resync completed!', 'success');
                }, 100);
            } else {
                // If not playing, just reset the state
                showMessage('Synchronization reset! Start playback to continue.', 'success');
            }
        }
        
        // Initial overlay size display and slider value
        overlaySizeSlider.value = overlaySize; // Set slider to 50
        overlaySizeValue.textContent = overlaySize + '%'; // Display 50%
        
        // Initial YouTube volume display
        youtubeVolumeValue.textContent = youtubeVolume + '%';
        
        // Add debug message for initial state
        addDebugMessage("Initialized with YouTube URL mode as default");
    });

    // Central synchronization logic (called by timeupdate or interval)
    function handleSynchronization(currentTime) {
        // Update debug info
        updateDebugInfo(currentTime);

        // First sync point handling
        if (isPlaying && waitingForFirstSync && firstSyncPoint) {
            // Check if we've reached the first sync point
            if (currentTime >= firstSyncPoint.reaction_time) {
                console.log("First sync point reached at reaction time:", currentTime);
                addDebugMessage(`First sync point reached at ${currentTime.toFixed(2)}s`);
                
                // Use exact relative_youtube_time for YouTube start
                let youtubeStartTime = 0;
                if (firstSyncPoint.relative_youtube_time !== null && firstSyncPoint.relative_youtube_time !== undefined) {
                    youtubeStartTime = firstSyncPoint.relative_youtube_time;
                    console.log("Using relative YouTube time:", youtubeStartTime);
                    addDebugMessage(`Using relative YouTube time: ${youtubeStartTime.toFixed(2)}s`);
                } else if (firstSyncPoint.youtube_time !== null) {
                    youtubeStartTime = firstSyncPoint.youtube_time;
                    console.log("Using original YouTube time:", youtubeStartTime);
                    addDebugMessage(`Using original YouTube time: ${youtubeStartTime.toFixed(2)}s`);
                }
                
                // Create YouTube player only when we reach the first sync point
                if (!youtubePlayerCreated && youtubeVideoId) {
                    createYouTubePlayer(youtubeVideoId, youtubeStartTime);
                } else if (youtubePlayer) {
                    if (youtubePlayer && youtubePlayer.seekTo && youtubePlayer.playVideo) {
                        youtubePlayer.seekTo(youtubeStartTime, true);
                        youtubePlayer.playVideo();
                    }
                    document.getElementById('youtube-container').style.display = 'block';
                }
                
                youtubeStarted = true;
                waitingForFirstSync = false;
                currentSyncPoint = firstSyncPoint;
                
                // Update next pause/play times
                updateNextEventTimes(currentTime);
                
                // Update status
                console.log('Status: Playing (YouTube started)');
            }
            return; // Don't process other events until first sync is done
        }
        
        // Check for missed events first
        if (isPlaying && youtubeStarted && missedEventCheckEnabled) {
            checkForMissedEvents(currentTime);
        }
        
        // Precise event detection with wider window
        if (isPlaying && youtubeStarted) {
            // Check for pause events with enhanced timing
            if (nextPauseTime !== null && currentTime >= nextPauseTime) {
                // Find the exact pause event with wider detection window
                const pauseEvent = findNearestEvent(pauseEvents, currentTime, eventDetectionWindow);
                
                if (pauseEvent && pauseEvent.reaction_time > lastProcessedPauseTime) {
                    console.log("Pause event detected at reaction time:", currentTime, "event time:", pauseEvent.reaction_time);
                    addDebugMessage(`Pause event detected at ${currentTime.toFixed(2)}s (event: ${pauseEvent.reaction_time.toFixed(2)}s)`);
                    
                    // Update last processed pause time
                    lastProcessedPauseTime = pauseEvent.reaction_time;
                    
                    // Use the exact relative_youtube_time from the pause event
                    if (youtubePlayer && !youtubePaused) {
                        youtubePaused = true;
                        
                        console.log("Pausing YouTube at exact time:", pauseEvent.relative_youtube_time);
                        addDebugMessage(`Pausing YouTube at ${pauseEvent.relative_youtube_time.toFixed(2)}s`);
                        
                        if (youtubePlayer && youtubePlayer.pauseVideo) {
                            youtubePlayer.pauseVideo();
                        }
                        
                        console.log('Status updated');
                        showMessage(`YouTube video paused at ${pauseEvent.relative_youtube_time.toFixed(2)}s`, 'success');
                    }
                    
                    // Update next event times
                    updateNextEventTimes(currentTime);
                }
            }
            
            // Check for play events with enhanced timing
            if (nextPlayTime !== null && currentTime >= nextPlayTime) {
                // Find the exact play event with wider detection window
                const playEvent = findNearestEvent(playEvents, currentTime, eventDetectionWindow);
                
                if (playEvent && playEvent.reaction_time > lastProcessedPlayTime) {
                    console.log("Play event detected at reaction time:", currentTime, "event time:", playEvent.reaction_time);
                    addDebugMessage(`Play event detected at ${currentTime.toFixed(2)}s (event: ${playEvent.reaction_time.toFixed(2)}s)`);
                    
                    // Update last processed play time
                    lastProcessedPlayTime = playEvent.reaction_time;
                    
                    // Use the exact relative_youtube_time from the play event
                    if (youtubePlayer) {
                        youtubePaused = false;
                        
                        console.log("Resuming YouTube at exact time:", playEvent.relative_youtube_time);
                        addDebugMessage(`Resuming YouTube at ${playEvent.relative_youtube_time.toFixed(2)}s`);
                        
                        if (youtubePlayer && youtubePlayer.seekTo && youtubePlayer.playVideo) {
                            youtubePlayer.seekTo(playEvent.relative_youtube_time, true);
                            youtubePlayer.playVideo();
                        }
                        
                        currentSyncPoint = playEvent;
                        
                        console.log('Status updated');
                        showMessage(`YouTube video resumed at ${playEvent.relative_youtube_time.toFixed(2)}s`, 'success');
                    }
                    
                    // Update next event times
                    updateNextEventTimes(currentTime);
                }
            }
            
            // Only perform regular synchronization if not paused and in precise mode
            if (!youtubePaused && syncMode === 'precise') {
                synchronizeYouTubePosition(currentTime);
            }
            
            // Update last reaction time (only for file mode)
            if (!youtubeYoutubeMode) {
                lastReactionTime = currentTime;
            }
        }
    }

    // ENHANCED: Find nearest event with wider detection window
    function findNearestEvent(events, currentTime, maxDiff) {
        if (!events || events.length === 0) return null;
        
        let nearestEvent = null;
        let minDiff = maxDiff;
        
        for (const event of events) {
            const diff = Math.abs(event.reaction_time - currentTime);
            if (diff < minDiff) {
                minDiff = diff;
                nearestEvent = event;
            }
        }
        
        return nearestEvent;
    }

    // ENHANCED: Check for missed events
    function checkForMissedEvents(currentTime) {
        // Check for missed play events
        for (const event of playEvents) {
            if (event.reaction_time > lastProcessedPlayTime && 
                event.reaction_time < currentTime && 
                Math.abs(event.reaction_time - currentTime) < 2.0) {
                
                console.log("Catching up missed play event at:", event.reaction_time);
                addDebugMessage(`Catching up missed play event at ${event.reaction_time.toFixed(2)}s`);
                
                // Process the missed play event
                                    if (youtubePlayer && youtubePaused) {
                        youtubePaused = false;
                        
                        // Special handling for specific events
                        if (Math.abs(event.reaction_time - 43.858) < 0.1) {
                            console.log("Special handling for 43.858s play event");
                            addDebugMessage("Special handling for 43.858s play event");
                        }
                        
                        if (youtubePlayer && youtubePlayer.seekTo && youtubePlayer.playVideo) {
                            youtubePlayer.seekTo(event.relative_youtube_time, true);
                            youtubePlayer.playVideo();
                        }
                    
                    if (Math.abs(event.reaction_time - 70.681) < 0.1) {
                        console.log("Special handling for 70.681s play event");
                        addDebugMessage("Special handling for 70.681s play event");
                    }
                    
                    // Seek to exact position and play
                    if (youtubePlayer && youtubePlayer.seekTo && youtubePlayer.playVideo) {
                        youtubePlayer.seekTo(event.relative_youtube_time, true);
                        youtubePlayer.playVideo();
                    }
                    
                    // Update current sync point
                    currentSyncPoint = event;
                    
                    // Update status
                    console.log('Status updated');
                    showMessage(`YouTube video resumed at ${event.relative_youtube_time.toFixed(2)}s (catch-up)`, 'success');
                }
                
                // Update last processed play time
                lastProcessedPlayTime = event.reaction_time;
            }
        }
        
        // Check for missed pause events
        for (const event of pauseEvents) {
            if (event.reaction_time > lastProcessedPauseTime && 
                event.reaction_time < currentTime && 
                Math.abs(event.reaction_time - currentTime) < 2.0) {
                
                console.log("Catching up missed pause event at:", event.reaction_time);
                addDebugMessage(`Catching up missed pause event at ${event.reaction_time.toFixed(2)}s`);
                
                // Process the missed pause event
                if (youtubePlayer && !youtubePaused) {
                    youtubePaused = true;
                    
                    // Pause YouTube video
                    if (youtubePlayer && youtubePlayer.pauseVideo) {
                        youtubePlayer.pauseVideo();
                    }
                    
                    // Update status
                    console.log('Status updated');
                    showMessage(`YouTube video paused at ${event.relative_youtube_time.toFixed(2)}s (catch-up)`, 'success');
                }
                
                // Update last processed pause time
                lastProcessedPauseTime = event.reaction_time;
            }
        }
        
        // Update next event times
        updateNextEventTimes(currentTime);
    }

    // Create YouTube player with delayed initialization
    function createYouTubePlayer(videoId, startTime) {
        console.log("Creating YouTube player with video ID:", videoId, "starting at time:", startTime);
        addDebugMessage(`Creating YouTube player with video ID: ${videoId}, starting at time: ${startTime.toFixed(2)}s`);
        
        // Ensure startTime is a valid number
        if (startTime === null || startTime === undefined || isNaN(startTime) || startTime < 0) {
            console.log("Invalid startTime, defaulting to 0");
            addDebugMessage("Invalid startTime, defaulting to 0");
            startTime = 0;
        }
        
        // Create new YouTube player
        youtubePlayer = new YT.Player('youtube-player', {
            height: '100%',
            width: '100%',
            videoId: videoId,
            playerVars: {
                'playsinline': 1,
                'controls': 0, // Disable controls for better overlay experience
                'autoplay': 0, // Critical: No autoplay
                'start': Math.floor(startTime), // Set start time
                'rel': 0
            },
            events: {
                'onReady': function(event) {
                    console.log("YouTube player ready, setting volume and playing at time:", startTime);
                    addDebugMessage(`YouTube player ready, playing at time: ${startTime.toFixed(2)}s`);
                    
                    // Set volume
                    event.target.setVolume(youtubeVolume);
                    // Seek to exact time (more precise than 'start' parameter)
                    event.target.seekTo(startTime, true);
                    // Play video
                    event.target.playVideo();
                    
                    // Show the YouTube container
                    document.getElementById('youtube-container').style.display = 'block';
                    
                    // Apply overlay settings
                    updateOverlayPosition();
                    updateOverlaySize();
                    updateOverlayVisibility();
                },
                'onStateChange': onPlayerStateChange
            }
        });
        
        youtubePlayerCreated = true;
    }

    // Reaction YouTube player ready callback
    function onReactionPlayerReady(event) {
        console.log('Status updated');
        reactionYoutubeReady = true;
        addDebugMessage("Reaction YouTube player ready");
        
        // If playback was started before player was ready, start sync now
        if (youtubeYoutubeMode && isPlaying) {
            startYoutubeYoutubeSync();
        }
    }

    // Reaction YouTube player state change callback
    function onReactionPlayerStateChange(event) {
        // Store the current state
        reactionYoutubeState = event.data;
        reactionYoutubeStateChangeTime = Date.now();
        
        // Handle reaction player state changes
        if (youtubeYoutubeMode && isPlaying) {
            if (event.data === YT.PlayerState.PLAYING) {
                addDebugMessage("Reaction YouTube player started playing");
                // Synchronization is handled by the interval
            } else if (event.data === YT.PlayerState.PAUSED) {
                addDebugMessage("Reaction YouTube player paused");
                // If original YouTube player exists and is playing, pause it
                if (youtubePlayer && youtubePlayerCreated && youtubePlayer.getPlayerState() === YT.PlayerState.PLAYING && youtubePlayer.pauseVideo) {
                    youtubePlayer.pauseVideo();
                    addDebugMessage("Paused original YouTube player due to reaction pause");
                }
            } else if (event.data === YT.PlayerState.ENDED) {
                addDebugMessage("Reaction YouTube player ended");
                stopSynchronizedPlayback();
            }
        }
    }

    // YouTube player state change callback
    function onPlayerStateChange(event) {
        // Handle YouTube player state changes if needed
        // We generally don't want the original player to control the reaction player
    }

    // Find sync point for a given reaction time
    function findSyncPointForTime(reactionTime) {
        // Find the nearest sync point before the given reaction time
        let nearestPoint = null;
        let minDiff = Infinity;
        
        for (const point of playEvents) {
            if (point.reaction_time <= reactionTime) {
                const diff = reactionTime - point.reaction_time;
                if (diff < minDiff) {
                    minDiff = diff;
                    nearestPoint = point;
                }
            }
        }
        
        return nearestPoint;
    }

    // Start YouTube-YouTube synchronization interval
    function startYoutubeYoutubeSync() {
        if (youtubeYoutubeSyncInterval) {
            clearInterval(youtubeYoutubeSyncInterval);
        }
        
        youtubeYoutubeSyncInterval = setInterval(function() {
            if (!youtubeYoutubeMode || !isPlaying || !reactionYoutubeReady) return;
            
            // Get current time of reaction video
            try {
                reactionYoutubeCurrentTime = reactionYoutubePlayer.getCurrentTime();
                
                // Call the central synchronization logic
                handleSynchronization(reactionYoutubeCurrentTime);
                
                // Update last reaction YouTube time
                lastReactionYoutubeTime = reactionYoutubeCurrentTime;
            } catch (error) {
                console.error("Error in YouTube-YouTube sync interval:", error);
                addDebugMessage(`ERROR in YouTube-YouTube sync: ${error.message}`);
            }
        }, youtubeYoutubeSyncFrequency);
        
        addDebugMessage("Started YouTube-YouTube synchronization interval");
    }

    // ENHANCED: Update next event times based on current position
    function updateNextEventTimes(currentTime) {
        // Find next pause event
        nextPauseTime = null;
        for (const event of pauseEvents) {
            if (event.reaction_time > currentTime) {
                nextPauseTime = event.reaction_time;
                console.log("Next pause at reaction time:", nextPauseTime, "YouTube time:", event.relative_youtube_time);
                addDebugMessage(`Next pause at ${nextPauseTime.toFixed(2)}s -> YouTube ${event.relative_youtube_time.toFixed(2)}s`);
                break;
            }
        }
        
        // Find next play event
        nextPlayTime = null;
        for (const event of playEvents) {
            if (event.reaction_time > currentTime) {
                nextPlayTime = event.reaction_time;
                console.log("Next play at reaction time:", nextPlayTime, "YouTube time:", event.relative_youtube_time);
                addDebugMessage(`Next play at ${nextPlayTime.toFixed(2)}s -> YouTube ${event.relative_youtube_time.toFixed(2)}s`);
                break;
            }
        }
        
        // Update debug display
        updateDebugDisplay();
    }



    // ENHANCED: Synchronize YouTube position based on current time
    function synchronizeYouTubePosition(currentTime) {
        if (!youtubePlayer || !currentSyncPoint || !youtubeStarted) return;
        
        // Check if YouTube player is fully ready
        if (!youtubePlayer.getCurrentTime || typeof youtubePlayer.getCurrentTime !== 'function') {
            return; // Player not ready yet, skip this sync cycle
        }
        
        try {
            // Calculate expected YouTube time based on current sync point
            const timeSinceSyncPoint = currentTime - currentSyncPoint.reaction_time;
            let expectedYoutubeTime = currentSyncPoint.relative_youtube_time + timeSinceSyncPoint;
            
            // Get current YouTube time
            const currentYoutubeTime = youtubePlayer.getCurrentTime();
            
            // Only sync if difference is significant
            if (Math.abs(currentYoutubeTime - expectedYoutubeTime) > youtubeYoutubeSyncThreshold) {
                console.log("Syncing YouTube time from", currentYoutubeTime, "to", expectedYoutubeTime);
                addDebugMessage(`Syncing YouTube time from ${currentYoutubeTime.toFixed(2)}s to ${expectedYoutubeTime.toFixed(2)}s`);
                youtubePlayer.seekTo(expectedYoutubeTime, true);
            }
        } catch (error) {
            console.error("Error in YouTube synchronization:", error);
            // Don't add debug message for every error to avoid spam
        }
    }

    // Start synchronized playback
    function startSynchronizedPlayback() {
        if (isPlaying) return;
        
        // Get current reaction time
        let currentReactionTime = 0;
        if (reactionSource === 'file') {
            currentReactionTime = reactionPlayer.currentTime;
        } else {
            if (reactionYoutubeReady && reactionYoutubePlayer && reactionYoutubePlayer.getCurrentTime) {
                try {
                    currentReactionTime = reactionYoutubePlayer.getCurrentTime();
                } catch (error) {
                    console.error("Error getting reaction YouTube time:", error);
                    currentReactionTime = 0;
                }
            }
        }
        
        // Clear debug info
        debugInfo = [];
        addDebugMessage(`Starting playback at reaction time: ${currentReactionTime.toFixed(2)}s`);
        
        isPlaying = true;
        
        // ENHANCED: Check if we're starting from the beginning or before the first sync point
        if (firstSyncPoint && currentReactionTime < firstSyncPoint.reaction_time) {
            console.log("Starting from beginning or before first sync point");
            addDebugMessage("Starting from beginning or before first sync point");
            waitingForFirstSync = true;
            console.log('Status updated');
        } else {
            // We're already past the first sync point, find the nearest sync point
            console.log("Starting from middle, finding nearest sync point");
            addDebugMessage("Starting from middle, finding nearest sync point");
            waitingForFirstSync = false;
            
            let nearestPoint = findSyncPointForTime(currentReactionTime);
            if (nearestPoint) {
                currentSyncPoint = nearestPoint;
                // Calculate expected YouTube time
                const timeSinceSyncPoint = currentReactionTime - nearestPoint.reaction_time;
                const expectedYoutubeTime = nearestPoint.relative_youtube_time + timeSinceSyncPoint;
                
                console.log("Using sync point:", nearestPoint);
                console.log("Expected YouTube time:", expectedYoutubeTime);
                addDebugMessage(`Using sync point at ${nearestPoint.reaction_time.toFixed(2)}s`);
                addDebugMessage(`Expected YouTube time: ${expectedYoutubeTime.toFixed(2)}s`);
                
                // Create or update YouTube player
                if (!youtubePlayerCreated) {
                    createYouTubePlayer(youtubeVideoId, expectedYoutubeTime);
                } else if (youtubePlayer && youtubePlayer.seekTo && youtubePlayer.playVideo) {
                    youtubePlayer.seekTo(expectedYoutubeTime, true);
                    youtubePlayer.playVideo();
                    document.getElementById('youtube-container').style.display = 'block';
                }
                youtubeStarted = true;
                updateNextEventTimes(currentReactionTime);
                console.log('Status updated');
            } else {
                showMessage('Could not find a sync point. Please restart.', 'error');
                addDebugMessage("ERROR: Could not find a sync point. Please restart.");
                updateDebugDisplay();
                isPlaying = false;
                return;
            }
        }
        
        // Play reaction video
        if (reactionSource === 'file') {
            reactionPlayer.play();
            // Start sync interval for file mode
            if (syncInterval) clearInterval(syncInterval);
            syncInterval = setInterval(() => {
                if (isPlaying && !youtubeYoutubeMode) {
                    handleSynchronization(reactionPlayer.currentTime);
                }
            }, 200); // File mode sync frequency
        } else {
            if (reactionYoutubeReady) {
                reactionYoutubePlayer.playVideo();
                addDebugMessage("Started reaction YouTube player");
                // Start YouTube-YouTube synchronization interval
                startYoutubeYoutubeSync();
            } else {
                addDebugMessage("Waiting for reaction YouTube player to be ready...");
                // Sync will start in onReactionPlayerReady
            }
        }
        
        // Reset YouTube pause state
        youtubePaused = false;
        lastProcessedPauseTime = -1;
        lastProcessedPlayTime = -1;
        lastReactionTime = currentReactionTime;
        
        updateButtonStates(true);
        updateDebugDisplay();
    }

    // Pause synchronized playback
    function pauseSynchronizedPlayback() {
        if (!isPlaying) return;
        isPlaying = false;
        
        // Pause reaction video
        if (reactionSource === 'file') {
            reactionPlayer.pause();
        } else {
            if (reactionYoutubeReady) {
                reactionYoutubePlayer.pauseVideo();
                addDebugMessage("Paused reaction YouTube player");
            }
        }
        
        // Pause YouTube video if it has started
        if (youtubeStarted && youtubePlayer && youtubePlayer.pauseVideo) {
            youtubePlayer.pauseVideo();
            addDebugMessage("Paused original YouTube player");
        }
        
        // Stop sync intervals
        if (syncInterval) {
            clearInterval(syncInterval);
            syncInterval = null;
        }
        if (youtubeYoutubeSyncInterval) {
            clearInterval(youtubeYoutubeSyncInterval);
            youtubeYoutubeSyncInterval = null;
            addDebugMessage("Stopped YouTube-YouTube synchronization interval");
        }
        
        console.log('Status updated');
        addDebugMessage("Playback paused");
        updateDebugDisplay();
        updateButtonStates(false);
    }

    // Stop synchronized playback
    function stopSynchronizedPlayback() {
        isPlaying = false;
        waitingForFirstSync = false;
        
        // Stop and rewind reaction video
        if (reactionSource === 'file') {
            reactionPlayer.pause();
            reactionPlayer.currentTime = 0;
        } else {
            if (reactionYoutubeReady && reactionYoutubePlayer && reactionYoutubePlayer.pauseVideo && reactionYoutubePlayer.seekTo) {
                reactionYoutubePlayer.pauseVideo();
                reactionYoutubePlayer.seekTo(0, true);
                addDebugMessage("Stopped and rewound reaction YouTube player");
            }
        }
        
        // Stop YouTube video if it exists
        if (youtubePlayer && youtubePlayer.pauseVideo && youtubePlayer.seekTo) {
            youtubePlayer.pauseVideo();
            youtubePlayer.seekTo(0, true);
            
            // Hide YouTube container
            document.getElementById('youtube-container').style.display = 'none';
            addDebugMessage("Stopped and rewound original YouTube player");
        }
        
        // Stop sync intervals
        if (syncInterval) {
            clearInterval(syncInterval);
            syncInterval = null;
        }
        if (youtubeYoutubeSyncInterval) {
            clearInterval(youtubeYoutubeSyncInterval);
            youtubeYoutubeSyncInterval = null;
            addDebugMessage("Stopped YouTube-YouTube synchronization interval");
        }
        
        console.log('Status updated');
        addDebugMessage("Playback stopped");
        updateDebugDisplay();
        updateButtonStates(false);
        
        // Reset YouTube started flag
        youtubeStarted = false;
        youtubePaused = false;
        currentSyncPoint = null;
        nextPauseTime = null;
        nextPlayTime = null;
        lastProcessedPauseTime = -1;
        lastProcessedPlayTime = -1;
        lastReactionTime = 0;
        reactionYoutubeCurrentTime = 0;
        lastReactionYoutubeTime = 0;
    }

    // Restart synchronized playback
    function restartSynchronizedPlayback() {
        // Rewind reaction video
        if (reactionSource === 'file') {
            reactionPlayer.currentTime = 0;
        } else {
            if (reactionYoutubeReady && reactionYoutubePlayer && reactionYoutubePlayer.seekTo) {
                reactionYoutubePlayer.seekTo(0, true);
                addDebugMessage("Rewound reaction YouTube player");
            }
        }
        
        // Reset YouTube started flag
        youtubeStarted = false;
        waitingForFirstSync = false;
        
        // Hide YouTube container
        document.getElementById('youtube-container').style.display = 'none';
        
        // Reset YouTube pause state
        youtubePaused = false;
        currentSyncPoint = null;
        nextPauseTime = null;
        nextPlayTime = null;
        lastProcessedPauseTime = -1;
        lastProcessedPlayTime = -1;
        lastReactionTime = 0;
        reactionYoutubeCurrentTime = 0;
        lastReactionYoutubeTime = 0;
        
        // Clear debug info
        debugInfo = [];
        addDebugMessage("Restarting playback");
        updateDebugDisplay();
        
        // Start playback
        startSynchronizedPlayback();
    }

    // ENHANCED: Add debug message
    function addDebugMessage(message) {
        const timestamp = new Date().toISOString().substr(11, 8);
        debugInfo.push(`[${timestamp}] ${message}`);
        
        // Keep only the last 50 messages
        if (debugInfo.length > 50) {
            debugInfo.shift();
        }
        // Update display immediately for important messages
        updateDebugDisplay(); 
    }

    // ENHANCED: Update debug info with current state
    function updateDebugInfo(currentTime) {
        // This function is now less critical as handleSynchronization updates debug
        // Can be used for less frequent status updates if needed
    }

    // ENHANCED: Update debug display
    function updateDebugDisplay() {
        const debugContentElement = document.getElementById('debug-content');
        if (!debugContentElement) return;
        
        debugContentElement.innerHTML = debugInfo.join('<br>');
        
        // Scroll to bottom
        debugContentElement.scrollTop = debugContentElement.scrollHeight;
    }

    // Update overlay position
    function updateOverlayPosition() {
        const container = document.getElementById('youtube-container');
        
        // Remove all position classes
        container.classList.remove('overlay-top-right', 'overlay-top-left', 'overlay-bottom-right', 'overlay-bottom-left');
        
        // Add selected position class
        container.classList.add('overlay-' + overlayPosition);
    }

    // Update overlay size
    function updateOverlaySize() {
        const container = document.getElementById('youtube-container');
        container.style.width = overlaySize + '%';
    }

    // Update overlay visibility
    function updateOverlayVisibility() {
        const container = document.getElementById('youtube-container');
        container.style.display = isOverlayVisible && youtubeStarted ? 'block' : 'none';
    }

    // Update YouTube volume
    function updateYoutubeVolume() {
        if (youtubePlayer) {
            youtubePlayer.setVolume(youtubeVolume);
        }
    }

    // Extract YouTube video ID from URL
    function extractYouTubeVideoId(url) {
        const regExp = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#&?]*).*/;
        const match = url.match(regExp);
        return (match && match[7].length === 11) ? match[7] : null;
    }

    // Enable/disable controls
    function enableControls(enabled) {
        document.getElementById('play-btn').disabled = !enabled;
        document.getElementById('pause-btn').disabled = !enabled;
        document.getElementById('stop-btn').disabled = !enabled;
        document.getElementById('restart-btn').disabled = !enabled;
        document.getElementById('toggle-overlay').disabled = !enabled;
    }

    // Update button states
    function updateButtonStates(playing) {
        document.getElementById('play-btn').disabled = playing;
        document.getElementById('pause-btn').disabled = !playing;
        document.getElementById('stop-btn').disabled = !playing;
        document.getElementById('restart-btn').disabled = !playing;
    }

    // Show message
    function showMessage(text, type) {
        const messageElement = document.getElementById('message');
        messageElement.textContent = text;
        messageElement.className = `message ${type}`;
        messageElement.style.display = 'block';
        
        // Auto-hide success messages after 5 seconds
        if (type === 'success') {
            setTimeout(function() {
                if (messageElement.textContent === text) { // Clear only if message hasn't changed
                     messageElement.style.display = 'none';
                }
            }, 5000);
        }
    }

    // Hide message
    function hideMessage() {
        const messageElement = document.getElementById('message');
        messageElement.style.display = 'none';
    }

    // Load VE URL data from server
    function loadVEUrlFromServer(veId) {
        console.log("📡 Loading VE URL from server:", veId);
        addDebugMessage(`📡 Loading VE URL from server: ${veId}`);
        
        // Determine server URL
        const serverUrl = window.location.origin;
        const apiUrl = `${serverUrl}/api/ve-urls/${veId}`;
        
        console.log("🔗 API URL:", apiUrl);
        addDebugMessage(`🔗 API URL: ${apiUrl}`);
        
        fetch(apiUrl)
            .then(response => {
                console.log("📥 Response status:", response.status);
                addDebugMessage(`📥 Response status: ${response.status}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log("✅ VE URL data loaded successfully:", data);
                addDebugMessage("✅ VE URL data loaded successfully");
                addDebugMessage(`📊 Data structure: ${JSON.stringify(data, null, 2)}`);
                
                // Setup viewer with server data
                setupViewerWithServerData(data);
            })
            .catch(error => {
                console.error("❌ Failed to load VE URL from server:", error);
                addDebugMessage(`❌ Failed to load VE URL from server: ${error.message}`);
                showMessage('Failed to load VE URL data. Please check the URL.', 'error');
            });
    }

    // Setup viewer with server data
    function setupViewerWithServerData(data) {
        try {
            // Extract data from server response
            const veUrlData = data.ve_url;
            const timestampData = veUrlData.timestamp_data;
            const reactionUrl = veUrlData.reaction_url;
            const youtubeUrl = veUrlData.original_url;
            
            console.log("🔧 Setting up viewer with server data");
            addDebugMessage("🔧 Setting up viewer with server data");
            
            // Set timestamp data
            if (timestampData && timestampData.sync_points && timestampData.sync_points.length > 0) {
                // Clear existing events
                pauseEvents = [];
                playEvents = [];
                debugInfo = [];
                
                // Process all events
                timestampData.sync_points.forEach(point => {
                    // Store first play time
                    if (point.youtube_first_play_time !== undefined && point.youtube_first_play_time !== null) {
                        youtubeFirstPlayTime = point.youtube_first_play_time;
                    }
                    
                    // Categorize events
                    if (point.event === 'youtube_pause') {
                        pauseEvents.push(point);
                    } else if (point.event === 'youtube_play') {
                        playEvents.push(point);
                    }
                });
                
                // Sort events by reaction_time
                pauseEvents.sort((a, b) => a.reaction_time - b.reaction_time);
                playEvents.sort((a, b) => a.reaction_time - b.reaction_time);
                
                // Find first sync point (first play event)
                firstSyncPoint = playEvents.length > 0 ? playEvents[0] : null;
                
                if (firstSyncPoint) {
                    console.log("First sync point loaded:", firstSyncPoint);
                    console.log("All pause events:", pauseEvents);
                    console.log("All play events:", playEvents);
                    
                    addDebugMessage("Timestamp data loaded successfully");
                    addDebugMessage(`Found ${playEvents.length} play events and ${pauseEvents.length} pause events`);
                    
                    // Log all events for debugging
                    playEvents.forEach(event => {
                        addDebugMessage(`Play event at ${event.reaction_time.toFixed(2)}s -> YouTube ${event.relative_youtube_time.toFixed(2)}s`);
                    });
                    
                    pauseEvents.forEach(event => {
                        addDebugMessage(`Pause event at ${event.reaction_time.toFixed(2)}s -> YouTube ${event.relative_youtube_time.toFixed(2)}s`);
                    });
                }
            }
            
            // Set reaction URL
            if (reactionUrl) {
                const reactionUrlElement = document.getElementById('reaction-url');
                if (reactionUrlElement) {
                    reactionUrlElement.value = reactionUrl;
                }
                
                // Extract reaction video YouTube ID
                const reactionVideoId = extractYouTubeVideoId(reactionUrl);
                if (reactionVideoId) {
                    // Remove existing reaction YouTube player
                    if (reactionYoutubePlayer) {
                        reactionYoutubePlayer.destroy();
                        reactionYoutubePlayer = null;
                    }
                    
                    // Set YouTube-YouTube mode flag
                    youtubeYoutubeMode = true;
                    reactionYoutubeReady = false;
                    
                    // Create new reaction YouTube player
                    reactionYoutubePlayer = new YT.Player('reaction-youtube-container', {
                        height: '540',
                        width: '100%',
                        videoId: reactionVideoId,
                        playerVars: {
                            'playsinline': 1,
                            'controls': 1,
                            'autoplay': 0,
                            'rel': 0
                        },
                        events: {
                            'onReady': onReactionPlayerReady,
                            'onStateChange': onReactionPlayerStateChange
                        }
                    });
                    
                    addDebugMessage(`Created reaction YouTube player with video ID: ${reactionVideoId}`);
                }
            }
            
            // Set YouTube URL
            if (youtubeUrl) {
                const youtubeUrlElement = document.getElementById('youtube-url');
                if (youtubeUrlElement) {
                    youtubeUrlElement.value = youtubeUrl;
                }
                
                // Extract YouTube video ID
                youtubeVideoId = extractYouTubeVideoId(youtubeUrl);
                if (youtubeVideoId) {
                    // Hide YouTube container until first sync point
                    document.getElementById('youtube-container').style.display = 'none';
                    
                    addDebugMessage(`YouTube video ID extracted: ${youtubeVideoId}`);
                }
            }
            
            // Apply server settings
            if (veUrlData.settings) {
                console.log("🔧 Applying server settings:", veUrlData.settings);
                addDebugMessage("🔧 Applying server settings");
                
                // Apply overlay position
                if (veUrlData.settings.overlay_position) {
                    const overlayPositionSelect = document.getElementById('overlay-position');
                    if (overlayPositionSelect) {
                        overlayPositionSelect.value = veUrlData.settings.overlay_position;
                        overlayPosition = veUrlData.settings.overlay_position;
                        updateOverlayPosition();
                    }
                }
                
                // Apply overlay size
                if (veUrlData.settings.overlay_size) {
                    const overlaySizeSlider = document.getElementById('overlay-size');
                    const overlaySizeValue = document.getElementById('overlay-size-value');
                    if (overlaySizeSlider) {
                        overlaySizeSlider.value = veUrlData.settings.overlay_size;
                        overlaySizeValue.textContent = veUrlData.settings.overlay_size + '%';
                        overlaySize = veUrlData.settings.overlay_size;
                        updateOverlaySize();
                    }
                }
                
                // Apply YouTube volume
                if (veUrlData.settings.youtube_volume) {
                    const youtubeVolumeSlider = document.getElementById('youtube-volume');
                    const youtubeVolumeValue = document.getElementById('youtube-volume-value');
                    if (youtubeVolumeSlider) {
                        youtubeVolumeSlider.value = veUrlData.settings.youtube_volume;
                        youtubeVolumeValue.textContent = veUrlData.settings.youtube_volume + '%';
                        youtubeVolume = veUrlData.settings.youtube_volume;
                        updateYoutubeVolume();
                    }
                }
                
                // Apply hide overlay setting
                if (veUrlData.settings.hide_overlay !== undefined) {
                    isOverlayVisible = !veUrlData.settings.hide_overlay;
                    updateOverlayVisibility();
                    const toggleOverlayBtn = document.getElementById('toggle-overlay');
                    if (toggleOverlayBtn) {
                        toggleOverlayBtn.textContent = isOverlayVisible ? 'Hide Overlay' : 'Show Overlay';
                    }
                }
            }
            
            // Update status
            console.log('Status updated');
            enableControls(true);
            showMessage('VE URL data loaded successfully. Click Play to start.', 'success');
            updateDebugDisplay();
            
        } catch (error) {
            console.error("❌ Error setting up viewer with server data:", error);
            addDebugMessage(`❌ Error setting up viewer with server data: ${error.message}`);
            showMessage('Error setting up viewer with server data.', 'error');
        }
    }

    // Auto-load for VE server mode
    function autoLoadForVEServer() {
        const urlParams = new URLSearchParams(window.location.search);
        const veId = urlParams.get('ve');
        
        if (veId) {
            console.log("🔄 Auto-loading VE URL data");
            addDebugMessage("🔄 Auto-loading VE URL data");
            loadVEUrlFromServer(veId);
        }
    }
    </script>
</body>
</html>

