<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="screen-orientation" content="portrait">
    <meta name="x5-orientation" content="portrait">
    <meta name="full-screen" content="yes">
    <meta name="x5-fullscreen" content="true">
    <title>Multi-Window-Viewer - Synchronized Reaction Video Player</title>
    <link rel="icon" href="favicon.ico">
    <!-- External CSS Files -->
    <link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet" href="css/mobile.css">
    <link rel="stylesheet" href="css/fullscreen.css">
    <link rel="stylesheet" href="css/components.css">

    



</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <div class="header-content">
                <div class="header-center">
                    <h1>
                        <div class="header-logo"></div>
                        Multi-Window-Viewer
                        <span class="beta-tag">Beta</span>
                        <button class="info-icon" id="infoIcon" title="Learn more about this solution">i</button>
                        <a href="/" class="create-own-btn" title="Create your own reaction video">Create My Own</a>
                        <div class="apple-tooltip" id="appleTooltip">
                            <div class="apple-tooltip-header">
                                <h3 class="apple-tooltip-title">VirtuEDIT Technology</h3>
                                <div class="apple-tooltip-subtitle">US Patent Registered ‚Ä¢ First ever IP Solution for Video Platforms</div>
                            </div>
                            
                            <div class="apple-tooltip-section">
                                <p class="apple-tooltip-section-content" style="line-height: 1.2;">
                                    Millisecond precision synchronization.<br>
                                    Real YouTube videos played simultaneously.
                                </p>
                            </div>

                            <div class="apple-tooltip-highlight">
                                <div class="apple-tooltip-highlight-title">Everyone Wins</div>
                                <div class="apple-tooltip-highlight-content" style="color: #fff; font-size: 14px;">
                                    <strong style="font-weight: 600;">Reactors:</strong> Monetize without copyright fears<br>
                                    <strong style="font-weight: 600;">Artists:</strong> Get views & revenue from every reaction<br>
                                    <strong style="font-weight: 600;">Platforms:</strong> Revenue from previously non-monetizable content<br>
                                    <strong style="font-weight: 600;">Viewers:</strong> Perfect synchronized reaction experiences
                                </div>
                            </div>

                            <div class="apple-tooltip-section">
                                <p class="apple-tooltip-section-content">
                                    Official YouTube players only. All copyright protections intact.
                                </p>
                            </div>
                        </div>
                    </h1>

            </div>
        </header>

        <!-- Video Player Section - Now at the top -->
        <div class="video-container">
            <div class="main-video-box">
                                 <div class="video-title">
                     <div class="video-title-text">
                         <span>üé¨</span>
                         <span>Reaction Video</span>
                     </div>
                     <div class="overlay-toggle-desktop" style="display: flex; align-items: center; gap: var(--space-sm); background: rgba(255, 255, 255, 0.1); padding: 4px 8px; border-radius: var(--radius-sm); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2);">
                         <span style="font-size: var(--text-sm); color: rgba(255, 255, 255, 0.9);">Overlay Custom Settings</span>
                         <label class="toggle-switch">
                             <input type="checkbox" id="overlayToggleBtn">
                             <span class="toggle-slider">
                                 <span class="toggle-text-on">ON</span>
                                 <span class="toggle-text-off">OFF</span>
                             </span>
                         </label>
                     </div>
                 </div>
                <video id="reaction-player" controls style="display: none;"></video>
                <div id="reaction-youtube-container" style="display: block;"></div>
            </div>
            
            <div id="youtube-container" class="overlay-top-right">
                <div id="youtube-player"></div>
            </div>
        </div>

                        <!-- Quick Playback Controls - Right below video -->
        <div class="quick-controls">
            <button id="play-btn" class="btn btn-primary" disabled>Play</button>
            <button id="pause-btn" class="btn btn-secondary" disabled>Pause</button>
            <button id="restart-btn" class="btn btn-secondary" disabled>Restart</button>
            <button id="full-btn" class="inline-btn btn-secondary" style="display: none;">Full</button>
            <button id="help-btn" class="inline-btn btn-info">Help</button>
            <button id="resyncBtn" class="inline-btn">Resync</button>
            <button id="overlay-settings-btn" class="btn btn-secondary" data-overlay-settings>‚öôÔ∏è</button>
        </div>
        
        <!-- Beta Version Notice - Right below quick controls -->
        <div class="beta-notice">
            <div class="beta-notice-content">
                <span class="beta-notice-icon">‚ö†Ô∏è</span>
                <div class="beta-notice-text desktop-beta-text">
                    <strong>Beta Version</strong><br>
                    Continuous playback is stable. Jumping to other points works but may occasionally cause unexpected issues.<br>
                    If you experience problems or want more information, please press the Help button.
                </div>
                <div class="beta-notice-text mobile-beta-text" style="display: none;">
                    <strong>Beta Version</strong><br>
                    Continuous playback is stable. Jumping to other points works but may occasionally cause unexpected issues.<br>
                    <strong>Note:</strong> iPhone/iOS support is not yet available.
                </div>
            </div>
        </div>
        
        <!-- Overlay Settings Panel - Outside quick-controls -->
        <div class="overlay-settings-panel" id="overlaySettingsPanel" style="margin-top: 0;">
                <div class="overlay-settings-header">
                    <h3 class="overlay-settings-title">
                        <span>‚öôÔ∏è</span>
                        <span>Overlay Settings</span>
                        <button class="overlay-toggle-btn" id="overlayControlsToggleBtn" style="display: none;">‚ñ∂</button>
                    </h3>
                </div>
                
                <div class="compact-controls" id="overlayControls">
                    <div class="input-group">
                        <label for="overlay-position" class="input-label">Position</label>
                        <select id="overlay-position" class="input">
                        <option value="top-right">Top Right</option>
                        <option value="top-left">Top Left</option>
                        <option value="bottom-right">Bottom Right</option>
                        <option value="bottom-left">Bottom Left</option>
                    </select>
                </div>
                    
                    <div class="input-group">
                        <label for="overlay-size" class="input-label">Size</label>
                    <div class="slider-container">
                            <input type="range" id="overlay-size" min="10" max="60" value="50">
                        <span id="overlay-size-value" class="slider-value">50%</span>
                    </div>
                </div>
                    
                    <div class="input-group">
                        <label for="youtube-volume" class="input-label">Relative Volume</label>
                    <div class="slider-container">
                        <input type="range" id="youtube-volume" min="0" max="100" value="100">
                        <span id="youtube-volume-value" class="slider-value">100%</span>
                    </div>
                </div>

                                     <div class="input-group">
                         <label class="input-label">Visibility</label>
                         <button id="toggle-overlay" class="btn btn-secondary" disabled>Hide Overlay</button>
                     </div>
                </div>
            </div>
        </div>

        <!-- Message Display -->
        <div class="message" id="message"></div>
        
        <!-- Help FAQ -->
        <div class="help-faq" id="helpFaq" style="display: none; margin: 0; padding: 0;">
            <div class="help-header">
                <h3>‚ùì Help & FAQ</h3>
                <button class="help-close-btn" id="helpCloseBtn">√ó</button>
            </div>
            
            <div class="faq-content">
                <div class="faq-section">
                    <h4>‚ö†Ô∏è Common Issues & Solutions</h4>
                    <div class="compact-issue-box">
                        <h5>Jump to timestamp doesn't work properly</h5>
                        <p><strong>Solutions:</strong></p>
                        <ul>
                            <li>Use the <button class="inline-btn" id="resyncBtn">Resync</button> button to reset synchronization</li>
                            <li>Start playback from slightly before the start and end of the sync point (timestamp)</li>
                            <li>Try restarting from the beginning</li>
                            <li>Avoid interacting with the original video for smooth timestamp control</li>
                        </ul>
                    </div>

                    <div class="compact-issue-box">
                        <h5>Playback speed issues</h5>
                        <p>Beta version may have issues with playback speed changes. Try using normal speed (1x) for best results.</p>
                    </div>
                </div>
        
                <div class="faq-section">
                    <h4>üé¨ About YouTube Player</h4>
                    <p>We simply display the official YouTube player window as-is to ensure legal and ethical compliance. This means:</p>
                    <ul>
                        <li>Ads and recommended videos may appear (YouTube's standard behavior)</li>
                        <li>Original video is clickable but we recommend avoiding interaction for smooth timestamp control</li>
                        <li>All YouTube terms and copyright protections remain fully intact, ensuring no risk of disputes.</li>
                    </ul>
                </div>
            </div>
        </div>

        <footer>
            <p>This application is designed to watch reaction videos without copyright infringement.</p>
        </footer>
    </div>

    <!-- YouTube API -->
    <script src="https://www.youtube.com/iframe_api"></script>
    
    <!-- External JavaScript Files -->
    <script src="js/FullscreenManager.js"></script>
    <script src="js/VideoPlayer.js"></script>
    <script src="js/UIManager.js"></script>
    <script src="js/SettingsManager.js"></script>
    <script src="js/FileManager.js"></script>
    <script src="js/utils.js"></script>
    <script>
    // Fixed Viewer JavaScript - Completely Redesigned Synchronization Logic with Enhanced Event Detection
    // Version 7: Fixed YouTube-YouTube mode synchronization and player creation with improved UI and default YouTube URL mode

    // Global variables
    let youtubePlayer = null;
    let reactionPlayer = null;
    let timestampData = null;
    let syncInterval = null; // Interval for file mode sync
    let isPlaying = false;
    let youtubeReady = false;
    let overlayPosition = 'top-right'; // Default overlay position
    let overlaySize = 50; // Default overlay size (%) - Changed from 20% to 50%
    let reactionSource = 'youtube'; // 'file' or 'youtube' - Changed default to 'youtube'
    let reactionYoutubePlayer = null;
    let isOverlayVisible = true; // Overlay visibility
    let youtubeVolume = 100; // YouTube volume (0-100)

    // Critical timestamp variables
    let youtubeStarted = false; // Flag to track if YouTube video has started
    let firstSyncPoint = null; // Store the first sync point
    let waitingForFirstSync = false; // Flag to indicate we're waiting for first sync point
    let youtubePlayerCreated = false; // Flag to track if YouTube player has been created
    let youtubeVideoId = null; // Store YouTube video ID for delayed creation
    let youtubeFirstPlayTime = null; // Store the time when YouTube video was first played
    let lastProcessedPauseTime = -1; // Track the last processed pause event time
    let lastProcessedPlayTime = -1; // Track the last processed play event time
    let youtubePaused = false; // Track if YouTube is paused by timestamp
    let lastSyncTime = 0; // Track the last time we synchronized videos
    let debugInfo = []; // Store debug information

    // New variables for improved synchronization
    let pauseEvents = []; // Store all pause events for quick lookup
    let playEvents = []; // Store all play events for quick lookup
    let currentSyncPoint = null; // Current active sync point
    let nextPauseTime = null; // Next pause time in reaction video timeline
    let nextPlayTime = null; // Next play time in reaction video timeline
    let syncMode = 'precise'; // 'precise' or 'relaxed' synchronization mode
    let missedEventCheckEnabled = true; // Enable checking for missed events
    let eventDetectionWindow = 0.5; // Increased event detection window (seconds)
    let lastReactionTime = 0; // Last processed reaction time (for file mode)

    // YouTube-YouTube synchronization variables
    let youtubeYoutubeMode = true; // Flag to indicate if both videos are YouTube - Changed default to true
    let reactionYoutubeReady = false; // Flag to track if reaction YouTube player is ready
    let reactionYoutubeCurrentTime = 0; // Current time of reaction YouTube player
    let lastReactionYoutubeTime = 0; // Last time of reaction YouTube player
    let youtubeYoutubeSyncInterval = null; // Interval for YouTube-YouTube synchronization
    let reactionYoutubeStateChangeTime = 0; // Time of last state change in reaction YouTube player
    let youtubeYoutubeSyncEnabled = true; // Enable YouTube-YouTube synchronization
    let youtubeYoutubeSyncFrequency = 200; // Frequency of YouTube-YouTube synchronization in ms (Increased frequency)
    let youtubeYoutubeSyncThreshold = 0.3; // Threshold for YouTube-YouTube synchronization in seconds
    let reactionYoutubeState = -1; // Current state of reaction YouTube player

            // YouTube API callback
        function onYouTubeIframeAPIReady() {
            youtubeReady = true;
        }

    // DOM loaded event
    document.addEventListener('DOMContentLoaded', function() {
        // Prevent screen rotation on mobile
        if (window.innerWidth <= 768) {
            // Lock orientation to portrait
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('portrait').catch(function(error) {
                    // Silently handle orientation lock failure
                });
            }
            
            // Alternative method for older browsers
            if (window.orientation !== undefined) {
                window.addEventListener('orientationchange', function() {
                    if (window.orientation === 90 || window.orientation === -90) {
                        // Force portrait mode
                        document.body.style.transform = 'rotate(-90deg)';
                        document.body.style.transformOrigin = 'left top';
                        document.body.style.width = '100vh';
                        document.body.style.height = '100vw';
                        document.body.style.overflowX = 'hidden';
                        document.body.style.position = 'absolute';
                        document.body.style.top = '100%';
                        document.body.style.left = '0';
                    } else {
                        // Portrait mode - reset
                        document.body.style.transform = '';
                        document.body.style.transformOrigin = '';
                        document.body.style.width = '';
                        document.body.style.height = '';
                        document.body.style.overflowX = '';
                        document.body.style.position = '';
                        document.body.style.top = '';
                        document.body.style.left = '';
                    }
                });
            }
        }
        // Overlay settings panel controls
        const overlayToggleBtn = document.getElementById('overlayToggleBtn');
        const overlayControlsToggleBtn = document.getElementById('overlayControlsToggleBtn');
        const overlaySettingsBtn = document.getElementById('overlay-settings-btn');
        const overlaySettingsPanel = document.getElementById('overlaySettingsPanel');
        const overlayControls = document.getElementById('overlayControls');
        
        // Desktop overlay toggle functionality
        if (overlayToggleBtn) {
            overlayToggleBtn.addEventListener('change', function() {
                if (this.checked) {
                    overlaySettingsPanel.classList.add('show');
                } else {
                    overlaySettingsPanel.classList.remove('show');
                }
            });
        }
        
                // Mobile overlay controls toggle functionality
        if (overlayControlsToggleBtn && overlayControls) {
            overlayControlsToggleBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                if (window.innerWidth <= 768) {
                    const isHidden = overlayControls.style.display === 'none' || overlayControls.style.display === '';
                    overlayControls.style.display = isHidden ? 'grid' : 'none';
                    this.classList.toggle('collapsed');
                    this.textContent = isHidden ? '‚ñº' : '‚ñ∂';
                }
            });
        }
        
        // Overlay settings title click functionality
        const overlaySettingsTitle = document.querySelector('.overlay-settings-title');
        if (overlaySettingsTitle && overlayControls) {
            overlaySettingsTitle.addEventListener('click', function(e) {
                if (window.innerWidth <= 768) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const isHidden = overlayControls.style.display === 'none' || overlayControls.style.display === '';
                    overlayControls.style.display = isHidden ? 'grid' : 'none';
                    
                    // Update toggle button state
                    if (overlayControlsToggleBtn) {
                        overlayControlsToggleBtn.classList.toggle('collapsed');
                        overlayControlsToggleBtn.textContent = isHidden ? '‚ñº' : '‚ñ∂';
                    }
                }
            });
        }
        
        if (overlaySettingsBtn && overlaySettingsPanel) {
            overlaySettingsBtn.addEventListener('click', function() {
                overlaySettingsPanel.classList.toggle('show');
            });
        }
        
                         // Mobile: Set initial state for overlay controls
        if (window.innerWidth <= 768) {
            if (overlaySettingsPanel) {
                overlaySettingsPanel.classList.remove('show');
            }
            if (overlayControls) {
                overlayControls.style.display = 'none';
            }
            if (overlayControlsToggleBtn) {
                overlayControlsToggleBtn.textContent = '‚ñ∂';
                overlayControlsToggleBtn.classList.remove('collapsed');
            }
            
            // Show Full button on mobile
            const fullBtn = document.getElementById('full-btn');
            if (fullBtn) {
                fullBtn.style.display = 'inline-block';
            }
        }
        
        // Mobile: Controls are always visible between video and footer
        const quickControls = document.querySelector('.quick-controls');
        
        // Remove auto-hide functionality for mobile
        if (window.innerWidth <= 768) {
            if (quickControls) {
                quickControls.classList.remove('hidden');
            }
        }

        // Apple-style tooltip controls - Hover based
        const infoIcon = document.getElementById('infoIcon');
        const appleTooltip = document.getElementById('appleTooltip');
        
        if (infoIcon && appleTooltip) {
            // Show tooltip on hover
            infoIcon.addEventListener('mouseenter', function() {
                appleTooltip.classList.add('show');
            });
            
            // Hide tooltip when mouse leaves
            infoIcon.addEventListener('mouseleave', function() {
                appleTooltip.classList.remove('show');
            });
            
            // Also hide tooltip when mouse leaves the tooltip itself
            appleTooltip.addEventListener('mouseleave', function() {
                appleTooltip.classList.remove('show');
            });
        }
        // Check for VE URL in the URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const veId = urlParams.get('ve');
        
        if (veId) {
            addDebugMessage(`VE URL detected: ${veId}`);
            
            // Load VE URL data from server
            loadVEUrlFromServer(veId);
        }
        
        // Element references
        const timestampFileInput = document.getElementById('timestamp-file');
        const reactionVideoInput = document.getElementById('reaction-video');
        const reactionUrlInput = document.getElementById('reaction-url');
        const youtubeUrlInput = document.getElementById('youtube-url');
        const loadBtn = document.getElementById('load-btn');
        const playBtn = document.getElementById('play-btn');
        const pauseBtn = document.getElementById('pause-btn');

        const restartBtn = document.getElementById('restart-btn');
        const helpBtn = document.getElementById('help-btn');
        const helpFaq = document.getElementById('helpFaq');
        const helpCloseBtn = document.getElementById('helpCloseBtn');
        const resyncBtn = document.getElementById('resyncBtn');
        const messageElement = document.getElementById('message');
        const overlayPositionSelect = document.getElementById('overlay-position');
        const overlaySizeSlider = document.getElementById('overlay-size');
        const overlaySizeValue = document.getElementById('overlay-size-value');
        const sourceTypeRadios = document.querySelectorAll('input[name="reaction-source"]');
        const toggleOverlayBtn = document.getElementById('toggle-overlay');
        const youtubeVolumeSlider = document.getElementById('youtube-volume');
        const youtubeVolumeValue = document.getElementById('youtube-volume-value');
        
        reactionPlayer = document.getElementById('reaction-player');
        const reactionYoutubeContainer = document.getElementById('reaction-youtube-container');
        const youtubeContainer = document.getElementById('youtube-container');
        
        // Initially hide YouTube container until first sync point
        youtubeContainer.style.display = 'none';

        // Source type change event
        const fileSourceContainer = document.getElementById('file-source-container');
        const youtubeSourceContainer = document.getElementById('youtube-source-container');
        
        sourceTypeRadios.forEach(radio => {
            radio.addEventListener('change', function() {
                reactionSource = this.value;
                if (reactionSource === 'file') {
                    fileSourceContainer.style.display = 'block';
                    youtubeSourceContainer.style.display = 'none';
                    reactionPlayer.style.display = 'block';
                    reactionYoutubeContainer.style.display = 'none';
                    youtubeYoutubeMode = false;
                } else {
                    fileSourceContainer.style.display = 'none';
                    youtubeSourceContainer.style.display = 'block';
                    reactionPlayer.style.display = 'none';
                    reactionYoutubeContainer.style.display = 'block';
                    youtubeYoutubeMode = true;
                }
            });
        });

        // Overlay position change event
        overlayPositionSelect.addEventListener('change', function() {
            overlayPosition = this.value;
            updateOverlayPosition();
        });

        // Overlay size change event
        overlaySizeSlider.addEventListener('input', function() {
            overlaySize = parseInt(this.value);
            overlaySizeValue.textContent = overlaySize + '%';
            updateOverlaySize();
        });
        
        // Overlay toggle button event
        toggleOverlayBtn.addEventListener('click', function() {
            isOverlayVisible = !isOverlayVisible;
            updateOverlayVisibility();
            this.textContent = isOverlayVisible ? 'Hide Overlay' : 'Show Overlay';
        });
        
        // YouTube volume control event
        youtubeVolumeSlider.addEventListener('input', function() {
            youtubeVolume = parseInt(this.value);
            youtubeVolumeValue.textContent = youtubeVolume + '%';
            updateYoutubeVolume();
        });

        // Help button event
        if (helpBtn && helpFaq) {
            helpBtn.addEventListener('click', function() {
                // Show FAQ if hidden
                if (helpFaq.style.display === 'none') {
                    helpFaq.style.display = 'block';
                    
                    // Smooth scroll to FAQ
                    setTimeout(() => {
                        helpFaq.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'start',
                            inline: 'nearest'
                        });
                    }, 100);
                } else {
                    helpFaq.style.display = 'none';
                }
            });
        }

        // Help close button event
        if (helpCloseBtn && helpFaq) {
            helpCloseBtn.addEventListener('click', function() {
                helpFaq.style.display = 'none';
                
                // Scroll back to top smoothly
                window.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            });
        }

        // Inline resync button event
        if (resyncBtn) {
            resyncBtn.addEventListener('click', function() {
                resyncVideos();
            });
        }

        // Reaction player setup (HTML5 video)
        reactionPlayer.addEventListener('loadedmetadata', function() {
            console.log('Status: Reaction Video Loaded');
        });
        
        // Reaction video ended event (HTML5 video)
        reactionPlayer.addEventListener('ended', function() {
            stopSynchronizedPlayback();
        });
        
        // Reaction video timeupdate event (HTML5 video) - ONLY for file mode sync
        reactionPlayer.addEventListener('timeupdate', function() {
            // Only run this logic if in file mode
            if (!youtubeYoutubeMode) {
                const currentTime = reactionPlayer.currentTime;
                handleSynchronization(currentTime);
            }
        });

        // Timestamp file load
        if (timestampFileInput) {
            timestampFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    timestampData = JSON.parse(e.target.result);
                    
                    // ENHANCED: Pre-process all events for quick lookup
                    if (timestampData.sync_points && timestampData.sync_points.length > 0) {
                        // Clear existing events
                        pauseEvents = [];
                        playEvents = [];
                        debugInfo = [];
                        
                        // Process all events
                        timestampData.sync_points.forEach(point => {
                            // Store first play time
                            if (point.youtube_first_play_time !== undefined && point.youtube_first_play_time !== null) {
                                youtubeFirstPlayTime = point.youtube_first_play_time;
                            }
                            
                            // Categorize events
                            if (point.event === 'youtube_pause') {
                                pauseEvents.push(point);
                            } else if (point.event === 'youtube_play') {
                                playEvents.push(point);
                            }
                        });
                        
                        // Sort events by reaction_time
                        pauseEvents.sort((a, b) => a.reaction_time - b.reaction_time);
                        playEvents.sort((a, b) => a.reaction_time - b.reaction_time);
                        
                        // Find first sync point (first play event)
                        firstSyncPoint = playEvents.length > 0 ? playEvents[0] : null;
                        
                        if (firstSyncPoint) {
                            console.log("First sync point loaded:", firstSyncPoint);
                            console.log("All pause events:", pauseEvents);
                            console.log("All play events:", playEvents);
                            
                            addDebugMessage("Timestamp file loaded successfully");
                            addDebugMessage(`Found ${playEvents.length} play events and ${pauseEvents.length} pause events`);
                            
                            // Log all events for debugging
                            playEvents.forEach(event => {
                                addDebugMessage(`Play event at ${event.reaction_time.toFixed(2)}s -> YouTube ${event.relative_youtube_time.toFixed(2)}s`);
                            });
                            
                            pauseEvents.forEach(event => {
                                addDebugMessage(`Pause event at ${event.reaction_time.toFixed(2)}s -> YouTube ${event.relative_youtube_time.toFixed(2)}s`);
                            });
                        }
                    }
                    
                    showMessage('Timestamp file loaded successfully.', 'success');
                    console.log('Status: Timestamp Loaded');
                    updateDebugDisplay();
                } catch (error) {
                    showMessage('Timestamp file parsing error: ' + error.message, 'error');
                }
            };
            reader.onerror = function() {
                showMessage('Error reading file.', 'error');
            };
            reader.readAsText(file);
            });
        }

        // Reaction video load (file)
        if (reactionVideoInput) {
            reactionVideoInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const url = URL.createObjectURL(file);
            reactionPlayer.src = url;
            showMessage('Reaction video loaded.', 'success');
            });
        }

        // Load button click
        if (loadBtn) {
            loadBtn.addEventListener('click', function() {
            // Check if we're in VE server mode
            const urlParams = new URLSearchParams(window.location.search);
            const veId = urlParams.get('ve');
            
            if (veId) {
                // In VE server mode, load button should just re-trigger auto-load
                console.log("üîÑ Re-triggering auto-load in VE server mode");
                addDebugMessage("üîÑ Re-triggering auto-load in VE server mode");
                autoLoadForVEServer();
                return;
            }
            
            // Normal load logic for manual mode
            const youtubeUrl = youtubeUrlInput.value.trim();
            
            if (!timestampData) {
                showMessage('Please load timestamp file first.', 'error');
                return;
            }
            
            if (reactionSource === 'file' && !reactionPlayer.src) {
                showMessage('Please select reaction video first.', 'error');
                return;
            }
            
            if (reactionSource === 'youtube') {
                const reactionUrl = reactionUrlInput.value.trim();
                if (!reactionUrl) {
                    showMessage('Please enter reaction video URL.', 'error');
                    return;
                }
                
                // Extract reaction video YouTube ID
                const reactionVideoId = extractYouTubeVideoId(reactionUrl);
                if (!reactionVideoId) {
                    showMessage('Invalid reaction video YouTube URL.', 'error');
                    return;
                }
                
                // Remove existing reaction YouTube player
                if (reactionYoutubePlayer) {
                    reactionYoutubePlayer.destroy();
                    reactionYoutubePlayer = null;
                }
                
                // Set YouTube-YouTube mode flag
                youtubeYoutubeMode = true;
                reactionYoutubeReady = false;
                
                // Create new reaction YouTube player with improved height
                reactionYoutubePlayer = new YT.Player('reaction-youtube-container', {
                    height: '540', // 1.5Î∞∞ ÎÜíÏù¥ Ï¶ùÍ∞Ä (Í∏∞Î≥∏ 360pxÏùò 1.5Î∞∞)
                    width: '100%',
                    videoId: reactionVideoId,
                    playerVars: {
                        'playsinline': 1,
                        'controls': 0, // Disable controls for better overlay experience
                        'autoplay': 0,
                        'rel': 0,
                        'showinfo': 0, // Hide video title and uploader info
                        'modestbranding': 1, // Hide YouTube logo
                        'iv_load_policy': 3, // Hide video annotations
                        'fs': 0, // Disable fullscreen button
                        'cc_load_policy': 0, // Disable closed captions
                        'disablekb': 1 // Disable keyboard controls
                    },
                    events: {
                        'onReady': onReactionPlayerReady,
                        'onStateChange': onReactionPlayerStateChange
                    }
                });
                
                addDebugMessage(`Created reaction YouTube player with video ID: ${reactionVideoId}`);
            } else {
                // Set YouTube-YouTube mode flag to false for file mode
                youtubeYoutubeMode = false;
            }
            
            if (!youtubeUrl) {
                showMessage('Please enter YouTube URL.', 'error');
                return;
            }

            // Extract YouTube video ID
            youtubeVideoId = extractYouTubeVideoId(youtubeUrl);
            if (!youtubeVideoId) {
                showMessage('Invalid YouTube URL.', 'error');
                return;
            }

            // CRITICAL CHANGE: We don't create the YouTube player here anymore
            // We'll create it only when we reach the first sync point
            
            // If there was a previous player, destroy it
            if (youtubePlayer) {
                youtubePlayer.destroy();
                youtubePlayer = null;
                youtubePlayerCreated = false;
            }
            
            // Hide YouTube container until first sync point
            document.getElementById('youtube-container').style.display = 'none';

            console.log('Status: Ready to Play');
            enableControls(true);
            
            // Reset YouTube started flag
            youtubeStarted = false;
            waitingForFirstSync = false;
            
            // Reset tracking variables
            lastProcessedPauseTime = -1;
            lastProcessedPlayTime = -1;
            youtubePaused = false;
            currentSyncPoint = null;
            nextPauseTime = null;
            nextPlayTime = null;
            lastReactionTime = 0;
            reactionYoutubeCurrentTime = 0;
            lastReactionYoutubeTime = 0;
            
            // Clear debug info
            debugInfo = [];
            addDebugMessage("Ready to play. Click Play to start.");
            updateDebugDisplay();
            
            showMessage('All media loaded. Click Play to start.', 'success');
            });
        }

        // Play button click
        if (playBtn) {
            playBtn.addEventListener('click', function() {
            // Check if we're in VE server mode
            const urlParams = new URLSearchParams(window.location.search);
            const veId = urlParams.get('ve');
            
            if (veId) {
                // In VE server mode, check if data is loaded
                if (!youtubeVideoId) {
                    showMessage('Please load videos first.', 'error');
                    return;
                }
                
                if (reactionSource === 'file' && !reactionPlayer.src) {
                    showMessage('Please select reaction video first.', 'error');
                    return;
                }
                
                if (reactionSource === 'youtube' && !reactionYoutubePlayer) {
                    showMessage('Please load reaction video URL first.', 'error');
                    return;
                }
            } else {
                // Normal mode checks
                if (!youtubeVideoId) {
                    showMessage('Please load videos first.', 'error');
                    return;
                }
                
                if (reactionSource === 'file' && !reactionPlayer.src) {
                    showMessage('Please select reaction video first.', 'error');
                    return;
                }
                
                if (reactionSource === 'youtube' && !reactionYoutubePlayer) {
                    showMessage('Please load reaction video URL first.', 'error');
                    return;
                }
            }
            
            startSynchronizedPlayback();
            });
        }

        // Pause button click
        if (pauseBtn) {
            pauseBtn.addEventListener('click', function() {
                pauseSynchronizedPlayback();
            });
        }



        // Restart button click
        if (restartBtn) {
            restartBtn.addEventListener('click', function() {
                restartSynchronizedPlayback();
            });
        }

        // Full button click
        const fullBtn = document.getElementById('full-btn');
        if (fullBtn) {
            // Ï¥àÍ∏∞ Full Î≤ÑÌäº ÏÉÅÌÉú ÏÑ§Ï†ï
            fullBtn.textContent = 'Full';
            fullBtn.style.background = 'rgba(33, 150, 243, 0.2)';
            fullBtn.style.color = 'rgba(33, 150, 243, 0.9)';
            fullBtn.style.fontWeight = 'normal';
            
            fullBtn.addEventListener('click', async function() {
                console.log('Full button clicked!');
                console.log('FullscreenManager exists:', !!window.fullscreenManager);
                console.log('Current full mode:', window.fullscreenManager?.isInFullMode());
                console.log('Is playing:', isPlaying);
                
                // Only allow full mode when playing
                if (!isPlaying) {
                    showMessage('Please start playback first to use full mode.', 'warning');
                    return;
                }
                
                if (window.fullscreenManager && window.fullscreenManager.isInFullMode()) {
                    console.log('Exiting full mode...');
                    window.fullscreenManager.exitFullMode();
                    fullBtn.style.background = 'rgba(33, 150, 243, 0.2)';
                    fullBtn.style.color = 'rgba(33, 150, 243, 0.9)';
                    fullBtn.style.fontWeight = 'normal';
                } else if (window.fullscreenManager) {
                    console.log('Entering full mode...');
                    await window.fullscreenManager.enterFullMode();
                    fullBtn.style.background = 'rgba(194, 41, 31, 0.9)';
                    fullBtn.style.color = 'white';
                    fullBtn.style.fontWeight = 'bold';
                } else {
                    console.error('FullscreenManager not found!');
                }
            });
        }

        // Resync function for inline button
        function resyncVideos() {
            console.log("üîÑ Resync: Resetting synchronization");
            addDebugMessage("üîÑ Resync: Resetting synchronization");
            
            // Reset sync state
            youtubeStarted = false;
            waitingForFirstSync = false;
            currentSyncPoint = null;
            nextPauseTime = null;
            nextPlayTime = null;
            lastProcessedPauseTime = -1;
            lastProcessedPlayTime = -1;
            
            // If currently playing, restart playback
            if (isPlaying) {
                pauseSynchronizedPlayback();
                setTimeout(() => {
                    startSynchronizedPlayback();
                    showMessage('Resync completed!', 'success');
                }, 100);
            } else {
                // If not playing, just reset the state
                showMessage('Synchronization reset! Start playback to continue.', 'success');
            }
        }
        
        // Initial overlay size display and slider value
        overlaySizeSlider.value = overlaySize; // Set slider to 50
        overlaySizeValue.textContent = overlaySize + '%'; // Display 50%
        
        // Initial YouTube volume display
        youtubeVolumeValue.textContent = youtubeVolume + '%';
        
        // Add debug message for initial state
        addDebugMessage("Initialized with YouTube URL mode as default");
    });

    // Central synchronization logic (called by timeupdate or interval)
    function handleSynchronization(currentTime) {
        // Update debug info
        updateDebugInfo(currentTime);

        // First sync point handling
        if (isPlaying && waitingForFirstSync && firstSyncPoint) {
            // Check if we've reached the first sync point
            if (currentTime >= firstSyncPoint.reaction_time) {
                console.log("First sync point reached at reaction time:", currentTime);
                addDebugMessage(`First sync point reached at ${currentTime.toFixed(2)}s`);
                
                // Use exact relative_youtube_time for YouTube start
                let youtubeStartTime = 0;
                if (firstSyncPoint.relative_youtube_time !== null && firstSyncPoint.relative_youtube_time !== undefined) {
                    youtubeStartTime = firstSyncPoint.relative_youtube_time;
                    console.log("Using relative YouTube time:", youtubeStartTime);
                    addDebugMessage(`Using relative YouTube time: ${youtubeStartTime.toFixed(2)}s`);
                } else if (firstSyncPoint.youtube_time !== null) {
                    youtubeStartTime = firstSyncPoint.youtube_time;
                    console.log("Using original YouTube time:", youtubeStartTime);
                    addDebugMessage(`Using original YouTube time: ${youtubeStartTime.toFixed(2)}s`);
                }
                
                // Create YouTube player only when we reach the first sync point
                if (!youtubePlayerCreated && youtubeVideoId) {
                    createYouTubePlayer(youtubeVideoId, youtubeStartTime);
                } else if (youtubePlayer) {
                    if (youtubePlayer && youtubePlayer.seekTo && youtubePlayer.playVideo) {
                        youtubePlayer.seekTo(youtubeStartTime, true);
                        youtubePlayer.playVideo();
                    }
                    document.getElementById('youtube-container').style.display = 'block';
                }
                
                youtubeStarted = true;
                waitingForFirstSync = false;
                currentSyncPoint = firstSyncPoint;
                
                // Update next pause/play times
                updateNextEventTimes(currentTime);
                
                // Update status
                console.log('Status: Playing (YouTube started)');
            }
            return; // Don't process other events until first sync is done
        }
        
        // Check for missed events first
        if (isPlaying && youtubeStarted && missedEventCheckEnabled) {
            checkForMissedEvents(currentTime);
        }
        
        // Precise event detection with wider window
        if (isPlaying && youtubeStarted) {
            // Check for pause events with enhanced timing
            if (nextPauseTime !== null && currentTime >= nextPauseTime) {
                // Find the exact pause event with wider detection window
                const pauseEvent = findNearestEvent(pauseEvents, currentTime, eventDetectionWindow);
                
                if (pauseEvent && pauseEvent.reaction_time > lastProcessedPauseTime) {
                    console.log("Pause event detected at reaction time:", currentTime, "event time:", pauseEvent.reaction_time);
                    addDebugMessage(`Pause event detected at ${currentTime.toFixed(2)}s (event: ${pauseEvent.reaction_time.toFixed(2)}s)`);
                    
                    // Update last processed pause time
                    lastProcessedPauseTime = pauseEvent.reaction_time;
                    
                    // Use the exact relative_youtube_time from the pause event
                    if (youtubePlayer && !youtubePaused) {
                        youtubePaused = true;
                        
                        console.log("Pausing YouTube at exact time:", pauseEvent.relative_youtube_time);
                        addDebugMessage(`Pausing YouTube at ${pauseEvent.relative_youtube_time.toFixed(2)}s`);
                        
                        if (youtubePlayer && youtubePlayer.pauseVideo) {
                            youtubePlayer.pauseVideo();
                        }
                        
                        console.log('Status updated');
                        showMessage(`YouTube video paused at ${pauseEvent.relative_youtube_time.toFixed(2)}s`, 'success');
                    }
                    
                    // Update next event times
                    updateNextEventTimes(currentTime);
                }
            }
            
            // Check for play events with enhanced timing
            if (nextPlayTime !== null && currentTime >= nextPlayTime) {
                // Find the exact play event with wider detection window
                const playEvent = findNearestEvent(playEvents, currentTime, eventDetectionWindow);
                
                if (playEvent && playEvent.reaction_time > lastProcessedPlayTime) {
                    console.log("Play event detected at reaction time:", currentTime, "event time:", playEvent.reaction_time);
                    addDebugMessage(`Play event detected at ${currentTime.toFixed(2)}s (event: ${playEvent.reaction_time.toFixed(2)}s)`);
                    
                    // Update last processed play time
                    lastProcessedPlayTime = playEvent.reaction_time;
                    
                    // Use the exact relative_youtube_time from the play event
                    if (youtubePlayer) {
                        youtubePaused = false;
                        
                        console.log("Resuming YouTube at exact time:", playEvent.relative_youtube_time);
                        addDebugMessage(`Resuming YouTube at ${playEvent.relative_youtube_time.toFixed(2)}s`);
                        
                        if (youtubePlayer && youtubePlayer.seekTo && youtubePlayer.playVideo) {
                            youtubePlayer.seekTo(playEvent.relative_youtube_time, true);
                            youtubePlayer.playVideo();
                        }
                        
                        currentSyncPoint = playEvent;
                        
                        console.log('Status updated');
                        showMessage(`YouTube video resumed at ${playEvent.relative_youtube_time.toFixed(2)}s`, 'success');
                    }
                    
                    // Update next event times
                    updateNextEventTimes(currentTime);
                }
            }
            
            // Only perform regular synchronization if not paused and in precise mode
            if (!youtubePaused && syncMode === 'precise') {
                synchronizeYouTubePosition(currentTime);
            }
            
            // Update last reaction time (only for file mode)
            if (!youtubeYoutubeMode) {
                lastReactionTime = currentTime;
            }
        }
    }

    // ENHANCED: Find nearest event with wider detection window
    function findNearestEvent(events, currentTime, maxDiff) {
        if (!events || events.length === 0) return null;
        
        let nearestEvent = null;
        let minDiff = maxDiff;
        
        for (const event of events) {
            const diff = Math.abs(event.reaction_time - currentTime);
            if (diff < minDiff) {
                minDiff = diff;
                nearestEvent = event;
            }
        }
        
        return nearestEvent;
    }

    // ENHANCED: Check for missed events
    function checkForMissedEvents(currentTime) {
        // Check for missed play events
        for (const event of playEvents) {
            if (event.reaction_time > lastProcessedPlayTime && 
                event.reaction_time < currentTime && 
                Math.abs(event.reaction_time - currentTime) < 2.0) {
                
                console.log("Catching up missed play event at:", event.reaction_time);
                addDebugMessage(`Catching up missed play event at ${event.reaction_time.toFixed(2)}s`);
                
                // Process the missed play event
                                    if (youtubePlayer && youtubePaused) {
                        youtubePaused = false;
                        
                        // Special handling for specific events
                        if (Math.abs(event.reaction_time - 43.858) < 0.1) {
                            console.log("Special handling for 43.858s play event");
                            addDebugMessage("Special handling for 43.858s play event");
                        }
                        
                        if (youtubePlayer && youtubePlayer.seekTo && youtubePlayer.playVideo) {
                            youtubePlayer.seekTo(event.relative_youtube_time, true);
                            youtubePlayer.playVideo();
                        }
                    
                    if (Math.abs(event.reaction_time - 70.681) < 0.1) {
                        console.log("Special handling for 70.681s play event");
                        addDebugMessage("Special handling for 70.681s play event");
                    }
                    
                    // Seek to exact position and play
                    if (youtubePlayer && youtubePlayer.seekTo && youtubePlayer.playVideo) {
                        youtubePlayer.seekTo(event.relative_youtube_time, true);
                        youtubePlayer.playVideo();
                    }
                    
                    // Update current sync point
                    currentSyncPoint = event;
                    
                    // Update status
                    console.log('Status updated');
                    showMessage(`YouTube video resumed at ${event.relative_youtube_time.toFixed(2)}s (catch-up)`, 'success');
                }
                
                // Update last processed play time
                lastProcessedPlayTime = event.reaction_time;
            }
        }
        
        // Check for missed pause events
        for (const event of pauseEvents) {
            if (event.reaction_time > lastProcessedPauseTime && 
                event.reaction_time < currentTime && 
                Math.abs(event.reaction_time - currentTime) < 2.0) {
                
                console.log("Catching up missed pause event at:", event.reaction_time);
                addDebugMessage(`Catching up missed pause event at ${event.reaction_time.toFixed(2)}s`);
                
                // Process the missed pause event
                if (youtubePlayer && !youtubePaused) {
                    youtubePaused = true;
                    
                    // Pause YouTube video
                    if (youtubePlayer && youtubePlayer.pauseVideo) {
                        youtubePlayer.pauseVideo();
                    }
                    
                    // Update status
                    console.log('Status updated');
                    showMessage(`YouTube video paused at ${event.relative_youtube_time.toFixed(2)}s (catch-up)`, 'success');
                }
                
                // Update last processed pause time
                lastProcessedPauseTime = event.reaction_time;
            }
        }
        
        // Update next event times
        updateNextEventTimes(currentTime);
    }

    // Create YouTube player with delayed initialization
    function createYouTubePlayer(videoId, startTime) {
        console.log("Creating YouTube player with video ID:", videoId, "starting at time:", startTime);
        addDebugMessage(`Creating YouTube player with video ID: ${videoId}, starting at time: ${startTime.toFixed(2)}s`);
        
        // Ensure startTime is a valid number
        if (startTime === null || startTime === undefined || isNaN(startTime) || startTime < 0) {
            console.log("Invalid startTime, defaulting to 0");
            addDebugMessage("Invalid startTime, defaulting to 0");
            startTime = 0;
        }
        
        // Create new YouTube player
        youtubePlayer = new YT.Player('youtube-player', {
            height: '100%',
            width: '100%',
            videoId: videoId,
            playerVars: {
                'playsinline': 1,
                'controls': 0, // Disable controls for better overlay experience
                'autoplay': 0, // Critical: No autoplay
                'start': Math.floor(startTime), // Set start time
                'rel': 0,
                'showinfo': 0, // Hide video title and uploader info
                'modestbranding': 1, // Hide YouTube logo
                'iv_load_policy': 3, // Hide video annotations
                'fs': 0, // Disable fullscreen button
                'cc_load_policy': 0, // Disable closed captions
                'disablekb': 1 // Disable keyboard controls
            },
            events: {
                'onReady': function(event) {
                    console.log("YouTube player ready, setting volume and playing at time:", startTime);
                    addDebugMessage(`YouTube player ready, playing at time: ${startTime.toFixed(2)}s`);
                    
                    // Set volume
                    event.target.setVolume(youtubeVolume);
                    // Seek to exact time (more precise than 'start' parameter)
                    event.target.seekTo(startTime, true);
                    // Play video
                    event.target.playVideo();
                    
                    // Show the YouTube container
                    document.getElementById('youtube-container').style.display = 'block';
                    
                    // Apply overlay settings
                    updateOverlayPosition();
                    updateOverlaySize();
                    updateOverlayVisibility();
                },
                'onStateChange': onPlayerStateChange
            }
        });
        
        youtubePlayerCreated = true;
    }

    // Reaction YouTube player ready callback
    function onReactionPlayerReady(event) {
        console.log('Status updated');
        reactionYoutubeReady = true;
        addDebugMessage("Reaction YouTube player ready");
        
        // If playback was started before player was ready, start sync now
        if (youtubeYoutubeMode && isPlaying) {
            startYoutubeYoutubeSync();
        }
    }

    // Reaction YouTube player state change callback
    function onReactionPlayerStateChange(event) {
        // Store the current state
        reactionYoutubeState = event.data;
        reactionYoutubeStateChangeTime = Date.now();
        
        // Handle reaction player state changes
        if (youtubeYoutubeMode && isPlaying) {
            if (event.data === YT.PlayerState.PLAYING) {
                addDebugMessage("Reaction YouTube player started playing");
                // Synchronization is handled by the interval
            } else if (event.data === YT.PlayerState.PAUSED) {
                addDebugMessage("Reaction YouTube player paused");
                // If original YouTube player exists and is playing, pause it
                if (youtubePlayer && youtubePlayerCreated && youtubePlayer.getPlayerState() === YT.PlayerState.PLAYING && youtubePlayer.pauseVideo) {
                    youtubePlayer.pauseVideo();
                    addDebugMessage("Paused original YouTube player due to reaction pause");
                }
            } else if (event.data === YT.PlayerState.ENDED) {
                addDebugMessage("Reaction YouTube player ended");
                stopSynchronizedPlayback();
            }
        }
    }

    // YouTube player state change callback
    function onPlayerStateChange(event) {
        // Handle YouTube player state changes if needed
        // We generally don't want the original player to control the reaction player
    }

    // Find sync point for a given reaction time
    function findSyncPointForTime(reactionTime) {
        // Find the nearest sync point before the given reaction time
        let nearestPoint = null;
        let minDiff = Infinity;
        
        for (const point of playEvents) {
            if (point.reaction_time <= reactionTime) {
                const diff = reactionTime - point.reaction_time;
                if (diff < minDiff) {
                    minDiff = diff;
                    nearestPoint = point;
                }
            }
        }
        
        return nearestPoint;
    }

    // Start YouTube-YouTube synchronization interval
    function startYoutubeYoutubeSync() {
        if (youtubeYoutubeSyncInterval) {
            clearInterval(youtubeYoutubeSyncInterval);
        }
        
        youtubeYoutubeSyncInterval = setInterval(function() {
            if (!youtubeYoutubeMode || !isPlaying || !reactionYoutubeReady) return;
            
            // Get current time of reaction video
            try {
                reactionYoutubeCurrentTime = reactionYoutubePlayer.getCurrentTime();
                
                // Call the central synchronization logic
                handleSynchronization(reactionYoutubeCurrentTime);
                
                // Update last reaction YouTube time
                lastReactionYoutubeTime = reactionYoutubeCurrentTime;
            } catch (error) {
                console.error("Error in YouTube-YouTube sync interval:", error);
                addDebugMessage(`ERROR in YouTube-YouTube sync: ${error.message}`);
            }
        }, youtubeYoutubeSyncFrequency);
        
        addDebugMessage("Started YouTube-YouTube synchronization interval");
    }

    // ENHANCED: Update next event times based on current position
    function updateNextEventTimes(currentTime) {
        // Find next pause event
        nextPauseTime = null;
        for (const event of pauseEvents) {
            if (event.reaction_time > currentTime) {
                nextPauseTime = event.reaction_time;
                console.log("Next pause at reaction time:", nextPauseTime, "YouTube time:", event.relative_youtube_time);
                addDebugMessage(`Next pause at ${nextPauseTime.toFixed(2)}s -> YouTube ${event.relative_youtube_time.toFixed(2)}s`);
                break;
            }
        }
        
        // Find next play event
        nextPlayTime = null;
        for (const event of playEvents) {
            if (event.reaction_time > currentTime) {
                nextPlayTime = event.reaction_time;
                console.log("Next play at reaction time:", nextPlayTime, "YouTube time:", event.relative_youtube_time);
                addDebugMessage(`Next play at ${nextPlayTime.toFixed(2)}s -> YouTube ${event.relative_youtube_time.toFixed(2)}s`);
                break;
            }
        }
        
        // Update debug display
        updateDebugDisplay();
    }



    // ENHANCED: Synchronize YouTube position based on current time
    function synchronizeYouTubePosition(currentTime) {
        if (!youtubePlayer || !currentSyncPoint || !youtubeStarted) return;
        
        // Check if YouTube player is fully ready
        if (!youtubePlayer.getCurrentTime || typeof youtubePlayer.getCurrentTime !== 'function') {
            return; // Player not ready yet, skip this sync cycle
        }
        
        try {
            // Calculate expected YouTube time based on current sync point
            const timeSinceSyncPoint = currentTime - currentSyncPoint.reaction_time;
            let expectedYoutubeTime = currentSyncPoint.relative_youtube_time + timeSinceSyncPoint;
            
            // Get current YouTube time
            const currentYoutubeTime = youtubePlayer.getCurrentTime();
            
            // Only sync if difference is significant
            if (Math.abs(currentYoutubeTime - expectedYoutubeTime) > youtubeYoutubeSyncThreshold) {
                console.log("Syncing YouTube time from", currentYoutubeTime, "to", expectedYoutubeTime);
                addDebugMessage(`Syncing YouTube time from ${currentYoutubeTime.toFixed(2)}s to ${expectedYoutubeTime.toFixed(2)}s`);
                youtubePlayer.seekTo(expectedYoutubeTime, true);
            }
        } catch (error) {
            console.error("Error in YouTube synchronization:", error);
            // Don't add debug message for every error to avoid spam
        }
    }

    // Start synchronized playback
    function startSynchronizedPlayback() {
        if (isPlaying) return;
        
        // Get current reaction time
        let currentReactionTime = 0;
        if (reactionSource === 'file') {
            currentReactionTime = reactionPlayer.currentTime;
        } else {
            if (reactionYoutubeReady && reactionYoutubePlayer && reactionYoutubePlayer.getCurrentTime) {
                try {
                    currentReactionTime = reactionYoutubePlayer.getCurrentTime();
                } catch (error) {
                    console.error("Error getting reaction YouTube time:", error);
                    currentReactionTime = 0;
                }
            }
        }
        
        // Clear debug info
        debugInfo = [];
        addDebugMessage(`Starting playback at reaction time: ${currentReactionTime.toFixed(2)}s`);
        
        isPlaying = true;
        
        // ENHANCED: Check if we're starting from the beginning or before the first sync point
        if (firstSyncPoint && currentReactionTime < firstSyncPoint.reaction_time) {
            console.log("Starting from beginning or before first sync point");
            addDebugMessage("Starting from beginning or before first sync point");
            waitingForFirstSync = true;
            console.log('Status updated');
        } else {
            // We're already past the first sync point, find the nearest sync point
            console.log("Starting from middle, finding nearest sync point");
            addDebugMessage("Starting from middle, finding nearest sync point");
            waitingForFirstSync = false;
            
            let nearestPoint = findSyncPointForTime(currentReactionTime);
            if (nearestPoint) {
                currentSyncPoint = nearestPoint;
                // Calculate expected YouTube time
                const timeSinceSyncPoint = currentReactionTime - nearestPoint.reaction_time;
                const expectedYoutubeTime = nearestPoint.relative_youtube_time + timeSinceSyncPoint;
                
                console.log("Using sync point:", nearestPoint);
                console.log("Expected YouTube time:", expectedYoutubeTime);
                addDebugMessage(`Using sync point at ${nearestPoint.reaction_time.toFixed(2)}s`);
                addDebugMessage(`Expected YouTube time: ${expectedYoutubeTime.toFixed(2)}s`);
                
                // Create or update YouTube player
                if (!youtubePlayerCreated) {
                    createYouTubePlayer(youtubeVideoId, expectedYoutubeTime);
                } else if (youtubePlayer && youtubePlayer.seekTo && youtubePlayer.playVideo) {
                    youtubePlayer.seekTo(expectedYoutubeTime, true);
                    youtubePlayer.playVideo();
                    document.getElementById('youtube-container').style.display = 'block';
                }
                youtubeStarted = true;
                updateNextEventTimes(currentReactionTime);
                console.log('Status updated');
            } else {
                showMessage('Could not find a sync point. Please restart.', 'error');
                addDebugMessage("ERROR: Could not find a sync point. Please restart.");
                updateDebugDisplay();
                isPlaying = false;
                return;
            }
        }
        
        // Play reaction video
        if (reactionSource === 'file') {
            reactionPlayer.play();
            // Start sync interval for file mode
            if (syncInterval) clearInterval(syncInterval);
            syncInterval = setInterval(() => {
                if (isPlaying && !youtubeYoutubeMode) {
                    handleSynchronization(reactionPlayer.currentTime);
                }
            }, 200); // File mode sync frequency
        } else {
            if (reactionYoutubeReady) {
                reactionYoutubePlayer.playVideo();
                addDebugMessage("Started reaction YouTube player");
                // Start YouTube-YouTube synchronization interval
                startYoutubeYoutubeSync();
            } else {
                addDebugMessage("Waiting for reaction YouTube player to be ready...");
                // Sync will start in onReactionPlayerReady
            }
        }
        
        // Reset YouTube pause state
        youtubePaused = false;
        lastProcessedPauseTime = -1;
        lastProcessedPlayTime = -1;
        lastReactionTime = currentReactionTime;
        
        updateButtonStates(true);
        updateDebugDisplay();
    }

    // Pause synchronized playback
    function pauseSynchronizedPlayback() {
        if (!isPlaying) return;
        isPlaying = false;
        
        // Pause reaction video
        if (reactionSource === 'file') {
            reactionPlayer.pause();
        } else {
            if (reactionYoutubeReady) {
                reactionYoutubePlayer.pauseVideo();
                addDebugMessage("Paused reaction YouTube player");
            }
        }
        
        // Pause YouTube video if it has started
        if (youtubeStarted && youtubePlayer && youtubePlayer.pauseVideo) {
            youtubePlayer.pauseVideo();
            addDebugMessage("Paused original YouTube player");
        }
        
        // Stop sync intervals
        if (syncInterval) {
            clearInterval(syncInterval);
            syncInterval = null;
        }
        if (youtubeYoutubeSyncInterval) {
            clearInterval(youtubeYoutubeSyncInterval);
            youtubeYoutubeSyncInterval = null;
            addDebugMessage("Stopped YouTube-YouTube synchronization interval");
        }
        
        console.log('Status updated');
        addDebugMessage("Playback paused");
        updateDebugDisplay();
        updateButtonStates(false);
    }



    // Restart synchronized playback
    function restartSynchronizedPlayback() {
        // Rewind reaction video
        if (reactionSource === 'file') {
            reactionPlayer.currentTime = 0;
        } else {
            if (reactionYoutubeReady && reactionYoutubePlayer && reactionYoutubePlayer.seekTo) {
                reactionYoutubePlayer.seekTo(0, true);
                addDebugMessage("Rewound reaction YouTube player");
            }
        }
        
        // Reset YouTube started flag
        youtubeStarted = false;
        waitingForFirstSync = false;
        
        // Hide YouTube container
        document.getElementById('youtube-container').style.display = 'none';
        
        // Reset YouTube pause state
        youtubePaused = false;
        currentSyncPoint = null;
        nextPauseTime = null;
        nextPlayTime = null;
        lastProcessedPauseTime = -1;
        lastProcessedPlayTime = -1;
        lastReactionTime = 0;
        reactionYoutubeCurrentTime = 0;
        lastReactionYoutubeTime = 0;
        
        // Clear debug info
        debugInfo = [];
        addDebugMessage("Restarting playback");
        updateDebugDisplay();
        
        // Start playback
        startSynchronizedPlayback();
    }

    // ENHANCED: Add debug message
    function addDebugMessage(message) {
        const timestamp = new Date().toISOString().substr(11, 8);
        debugInfo.push(`[${timestamp}] ${message}`);
        
        // Keep only the last 50 messages
        if (debugInfo.length > 50) {
            debugInfo.shift();
        }
        // Update display immediately for important messages
        updateDebugDisplay(); 
    }

    // ENHANCED: Update debug info with current state
    function updateDebugInfo(currentTime) {
        // This function is now less critical as handleSynchronization updates debug
        // Can be used for less frequent status updates if needed
    }

    // ENHANCED: Update debug display
    function updateDebugDisplay() {
        const debugContentElement = document.getElementById('debug-content');
        if (!debugContentElement) return;
        
        debugContentElement.innerHTML = debugInfo.join('<br>');
        
        // Scroll to bottom
        debugContentElement.scrollTop = debugContentElement.scrollHeight;
    }

    // Update overlay position
    function updateOverlayPosition() {
        const container = document.getElementById('youtube-container');
        
        // Remove all position classes
        container.classList.remove('overlay-top-right', 'overlay-top-left', 'overlay-bottom-right', 'overlay-bottom-left');
        
        // Add selected position class
        container.classList.add('overlay-' + overlayPosition);
    }

    // Update overlay size
    function updateOverlaySize() {
        const container = document.getElementById('youtube-container');
        container.style.width = overlaySize + '%';
    }

    // Update overlay visibility
    function updateOverlayVisibility() {
        const container = document.getElementById('youtube-container');
        container.style.display = isOverlayVisible && youtubeStarted ? 'block' : 'none';
    }

    // Update YouTube volume
    function updateYoutubeVolume() {
        if (youtubePlayer) {
            youtubePlayer.setVolume(youtubeVolume);
        }
    }

    // Extract YouTube video ID from URL
    function extractYouTubeVideoId(url) {
        const regExp = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#&?]*).*/;
        const match = url.match(regExp);
        return (match && match[7].length === 11) ? match[7] : null;
    }

    // Enable/disable controls
    function enableControls(enabled) {
        document.getElementById('play-btn').disabled = !enabled;
        document.getElementById('pause-btn').disabled = !enabled;
        document.getElementById('restart-btn').disabled = !enabled;
        document.getElementById('full-btn').disabled = !enabled;
        document.getElementById('toggle-overlay').disabled = !enabled;
    }

    // Update button states
    function updateButtonStates(playing) {
        document.getElementById('play-btn').disabled = playing;
        document.getElementById('pause-btn').disabled = !playing;
        document.getElementById('restart-btn').disabled = false; // Restart Î≤ÑÌäºÏùÄ Ìï≠ÏÉÅ ÌôúÏÑ±Ìôî
        document.getElementById('full-btn').disabled = false; // Full Î≤ÑÌäºÏùÄ Ìï≠ÏÉÅ ÌôúÏÑ±Ìôî
    }

    // Show message
    function showMessage(text, type) {
        const messageElement = document.getElementById('message');
        messageElement.textContent = text;
        messageElement.className = `message ${type}`;
        messageElement.style.display = 'block';
        
        // Auto-hide success messages after 5 seconds
        if (type === 'success') {
            setTimeout(function() {
                if (messageElement.textContent === text) { // Clear only if message hasn't changed
                     messageElement.style.display = 'none';
                }
            }, 5000);
        }
    }

    // Hide message
    function hideMessage() {
        const messageElement = document.getElementById('message');
        messageElement.style.display = 'none';
    }

    // Load VE URL data from server
    function loadVEUrlFromServer(veId) {
        console.log("üì° Loading VE URL from server:", veId);
        addDebugMessage(`üì° Loading VE URL from server: ${veId}`);
        
        // Determine server URL
        const serverUrl = window.location.origin;
        const apiUrl = `${serverUrl}/api/ve-urls/${veId}`;
        
        console.log("üîó API URL:", apiUrl);
        addDebugMessage(`üîó API URL: ${apiUrl}`);
        
        fetch(apiUrl)
            .then(response => {
                console.log("üì• Response status:", response.status);
                addDebugMessage(`üì• Response status: ${response.status}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log("‚úÖ VE URL data loaded successfully:", data);
                addDebugMessage("‚úÖ VE URL data loaded successfully");
                addDebugMessage(`üìä Data structure: ${JSON.stringify(data, null, 2)}`);
                
                // Setup viewer with server data
                setupViewerWithServerData(data);
            })
            .catch(error => {
                console.error("‚ùå Failed to load VE URL from server:", error);
                addDebugMessage(`‚ùå Failed to load VE URL from server: ${error.message}`);
                showMessage('Failed to load VE URL data. Please check the URL.', 'error');
            });
    }

    // Setup viewer with server data
    function setupViewerWithServerData(data) {
        try {
            // Extract data from server response
            const veUrlData = data.ve_url;
            const timestampData = veUrlData.timestamp_data;
            const reactionUrl = veUrlData.reaction_url;
            const youtubeUrl = veUrlData.original_url;
            
            console.log("üîß Setting up viewer with server data");
            addDebugMessage("üîß Setting up viewer with server data");
            
            // Set timestamp data
            if (timestampData && timestampData.sync_points && timestampData.sync_points.length > 0) {
                // Clear existing events
                pauseEvents = [];
                playEvents = [];
                debugInfo = [];
                
                // Process all events
                timestampData.sync_points.forEach(point => {
                    // Store first play time
                    if (point.youtube_first_play_time !== undefined && point.youtube_first_play_time !== null) {
                        youtubeFirstPlayTime = point.youtube_first_play_time;
                    }
                    
                    // Categorize events
                    if (point.event === 'youtube_pause') {
                        pauseEvents.push(point);
                    } else if (point.event === 'youtube_play') {
                        playEvents.push(point);
                    }
                });
                
                // Sort events by reaction_time
                pauseEvents.sort((a, b) => a.reaction_time - b.reaction_time);
                playEvents.sort((a, b) => a.reaction_time - b.reaction_time);
                
                // Find first sync point (first play event)
                firstSyncPoint = playEvents.length > 0 ? playEvents[0] : null;
                
                if (firstSyncPoint) {
                    console.log("First sync point loaded:", firstSyncPoint);
                    console.log("All pause events:", pauseEvents);
                    console.log("All play events:", playEvents);
                    
                    addDebugMessage("Timestamp data loaded successfully");
                    addDebugMessage(`Found ${playEvents.length} play events and ${pauseEvents.length} pause events`);
                    
                    // Log all events for debugging
                    playEvents.forEach(event => {
                        addDebugMessage(`Play event at ${event.reaction_time.toFixed(2)}s -> YouTube ${event.relative_youtube_time.toFixed(2)}s`);
                    });
                    
                    pauseEvents.forEach(event => {
                        addDebugMessage(`Pause event at ${event.reaction_time.toFixed(2)}s -> YouTube ${event.relative_youtube_time.toFixed(2)}s`);
                    });
                }
            }
            
            // Set reaction URL
            if (reactionUrl) {
                const reactionUrlElement = document.getElementById('reaction-url');
                if (reactionUrlElement) {
                    reactionUrlElement.value = reactionUrl;
                }
                
                // Extract reaction video YouTube ID
                const reactionVideoId = extractYouTubeVideoId(reactionUrl);
                if (reactionVideoId) {
                    // Remove existing reaction YouTube player
                    if (reactionYoutubePlayer) {
                        reactionYoutubePlayer.destroy();
                        reactionYoutubePlayer = null;
                    }
                    
                    // Set YouTube-YouTube mode flag
                    youtubeYoutubeMode = true;
                    reactionYoutubeReady = false;
                    
                    // Create new reaction YouTube player
                    reactionYoutubePlayer = new YT.Player('reaction-youtube-container', {
                        height: '540',
                        width: '100%',
                        videoId: reactionVideoId,
                        playerVars: {
                            'playsinline': 1,
                            'controls': 0, // Disable controls for better overlay experience
                            'autoplay': 0,
                            'rel': 0,
                            'showinfo': 0, // Hide video title and uploader info
                            'modestbranding': 1, // Hide YouTube logo
                            'iv_load_policy': 3, // Hide video annotations
                            'fs': 0, // Disable fullscreen button
                            'cc_load_policy': 0, // Disable closed captions
                            'disablekb': 1 // Disable keyboard controls
                        },
                        events: {
                            'onReady': onReactionPlayerReady,
                            'onStateChange': onReactionPlayerStateChange
                        }
                    });
                    
                    addDebugMessage(`Created reaction YouTube player with video ID: ${reactionVideoId}`);
                }
            }
            
            // Set YouTube URL
            if (youtubeUrl) {
                const youtubeUrlElement = document.getElementById('youtube-url');
                if (youtubeUrlElement) {
                    youtubeUrlElement.value = youtubeUrl;
                }
                
                // Extract YouTube video ID
                youtubeVideoId = extractYouTubeVideoId(youtubeUrl);
                if (youtubeVideoId) {
                    // Hide YouTube container until first sync point
                    document.getElementById('youtube-container').style.display = 'none';
                    
                    addDebugMessage(`YouTube video ID extracted: ${youtubeVideoId}`);
                }
            }
            
            // Apply server settings
            if (veUrlData.settings) {
                console.log("üîß Applying server settings:", veUrlData.settings);
                addDebugMessage("üîß Applying server settings");
                
                // Apply overlay position
                if (veUrlData.settings.overlay_position) {
                    const overlayPositionSelect = document.getElementById('overlay-position');
                    if (overlayPositionSelect) {
                        overlayPositionSelect.value = veUrlData.settings.overlay_position;
                        overlayPosition = veUrlData.settings.overlay_position;
                        updateOverlayPosition();
                    }
                }
                
                // Apply overlay size
                if (veUrlData.settings.overlay_size) {
                    const overlaySizeSlider = document.getElementById('overlay-size');
                    const overlaySizeValue = document.getElementById('overlay-size-value');
                    if (overlaySizeSlider) {
                        overlaySizeSlider.value = veUrlData.settings.overlay_size;
                        overlaySizeValue.textContent = veUrlData.settings.overlay_size + '%';
                        overlaySize = veUrlData.settings.overlay_size;
                        updateOverlaySize();
                    }
                }
                
                // Apply YouTube volume
                if (veUrlData.settings.youtube_volume) {
                    const youtubeVolumeSlider = document.getElementById('youtube-volume');
                    const youtubeVolumeValue = document.getElementById('youtube-volume-value');
                    if (youtubeVolumeSlider) {
                        youtubeVolumeSlider.value = veUrlData.settings.youtube_volume;
                        youtubeVolumeValue.textContent = veUrlData.settings.youtube_volume + '%';
                        youtubeVolume = veUrlData.settings.youtube_volume;
                        updateYoutubeVolume();
                    }
                }
                
                // Apply hide overlay setting
                if (veUrlData.settings.hide_overlay !== undefined) {
                    isOverlayVisible = !veUrlData.settings.hide_overlay;
                    updateOverlayVisibility();
                    const toggleOverlayBtn = document.getElementById('toggle-overlay');
                    if (toggleOverlayBtn) {
                        toggleOverlayBtn.textContent = isOverlayVisible ? 'Hide Overlay' : 'Show Overlay';
                    }
                }
            }
            
            // Update status
            console.log('Status updated');
            enableControls(true);
            showMessage('VE URL data loaded successfully. Click Play to start.', 'success');
            updateDebugDisplay();
            
        } catch (error) {
            console.error("‚ùå Error setting up viewer with server data:", error);
            addDebugMessage(`‚ùå Error setting up viewer with server data: ${error.message}`);
            showMessage('Error setting up viewer with server data.', 'error');
        }
    }

    // Auto-load for VE server mode
    function autoLoadForVEServer() {
        const urlParams = new URLSearchParams(window.location.search);
        const veId = urlParams.get('ve');
        
        if (veId) {
            console.log("üîÑ Auto-loading VE URL data");
            addDebugMessage("üîÑ Auto-loading VE URL data");
            loadVEUrlFromServer(veId);
        }
    }
    </script>
</body>
</html>

