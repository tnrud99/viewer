<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="screen-orientation" content="portrait">
    <meta name="x5-orientation" content="portrait">
    <meta name="full-screen" content="yes">
    <meta name="x5-fullscreen" content="true">
    <title>Multi-Window-Viewer - Synchronized Reaction Video Player</title>
    <link rel="icon" href="favicon.ico">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

    
    <!-- 독립적인 스타일 (ui-system.css 참조하지 않음) -->
    <style>
        :root {
            /* 색상 시스템 - react-central과 통일 */
            --primary: #c12a1f;
            --primary-dark: #a01f17;
            --primary-light: #e63946;
            --accent: #00d4ff;
            --text: #1a1a1a;
            --text-secondary: #2a2a2a;
            --text-muted: #666666;
            --bg: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-card: rgba(255, 255, 255, 0.9);
            --border: rgba(193, 42, 31, 0.2);
            --shadow: 0 20px 40px rgba(193, 42, 31, 0.15);
            --dark-bg: #0f0f0f;
            --dark-card: #1a1a1a;
            --dark-text: #ffffff;
            --dark-text-secondary: #aaaaaa;
            
            /* 기존 변수들도 유지 (호환성) */
            --color-action: #c12a1f;
            --color-action-hover: #a01f17;
            --color-action-light: rgba(194, 41, 31, 0.1);
            --color-secondary: #4a4a4a;
            --color-secondary-hover: #5a5a5a;
            --color-success: #4caf50;
            --color-warning: #ff9800;
            --color-error: #f44336;
            --color-info: #2196f3;
            --color-bg-main: #ffffff;
            --color-bg-card: rgba(255, 255, 255, 0.9);
            --color-bg-input: rgba(255, 255, 255, 0.8);
            --color-text-main: #1a1a1a;
            --color-text-sub: #2a2a2a;
            --color-text-muted: #666666;
            --color-border: rgba(193, 42, 31, 0.2);
            --color-border-focus: rgba(193, 42, 31, 0.3);
            
            /* 간격 */
            --space-xs: 0.5rem;
            --space-sm: 0.75rem;
            --space-md: 1rem;
            --space-lg: 1.5rem;
            --space-xl: 2rem;
            
            /* 폰트 크기 */
            --text-xs: 0.75rem;
            --text-sm: 0.875rem;
            --text-base: 1rem;
            --text-lg: 1.125rem;
            --text-xl: 1.25rem;
            --text-2xl: 1.5rem;
            --text-3xl: 2rem;
            
            /* 둥근 모서리 */
            --radius-sm: 0.5rem;
            --radius-md: 0.75rem;
            --radius-lg: 1rem;
            --radius-xl: 1.5rem;
            
            /* 그림자 */
            --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.1);
            --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.2);
            --shadow-lg: 0 8px 16px rgba(0, 0, 0, 0.3);
            --shadow-action: 0 4px 12px rgba(194, 41, 31, 0.3);
            
            /* 애니메이션 */
            --transition: 0.2s ease;
            --transition-slow: 0.3s ease;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background: var(--dark-bg);
            color: var(--dark-text);
            min-height: 100vh;
            line-height: 1.6;
            overflow-x: hidden;
            /* Prevent screen rotation on mobile */
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            text-size-adjust: 100%;
        }
        
        /* 회전방지 코드 완전 제거 - 모바일에서 자연스러운 화면 표시 */

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: var(--space-lg);
            min-height: 100vh;
            margin-top: 40px; /* 고정 헤더를 위한 상단 마진 */
        }

        /* Header - react-central과 동일한 구조 */
        .header {
            position: fixed;
            top: 0;
            width: 100%;
            z-index: 1000;
            background: rgba(15, 15, 15, 0.95);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            height: 60px;
            padding: 0 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-sizing: border-box;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .header-center {
            flex: 1;
            max-width: 600px;
            margin: 0 20px;
            display: flex;
            justify-content: center;
        }

        .search-container {
            position: relative;
            width: 100%;
        }

        .search-bar {
            width: 100%;
            height: 40px;
            padding: 0 50px 0 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            font-size: 16px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            transition: all 0.2s ease;
        }

        .search-bar:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(193, 42, 31, 0.1);
        }

        .search-bar::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .search-btn {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: var(--primary);
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s ease;
        }

        .search-btn:hover {
            background: var(--primary-dark);
        }

        /* Mobile search button (standalone) */
        .mobile-search-btn {
            display: none;
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: background 0.2s ease;
        }

        .mobile-search-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .mobile-search-btn .material-icons {
            font-size: 24px;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .menu-btn {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: background 0.2s ease;
            color: white;
        }

        .menu-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .profile-btn {
            background: none;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: background 0.2s ease;
            position: relative;
        }

        .profile-btn .material-icons {
            color: white;
            font-size: 24px;
        }

        .profile-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .profile-menu {
            position: absolute;
            top: 50px;
            right: 0;
            background: var(--dark-card);
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 180px;
            z-index: 1000;
        }

        .profile-menu-item {
            padding: 12px 16px;
            cursor: pointer;
            transition: background 0.2s ease;
            font-size: 14px;
            color: var(--dark-text);
        }

        .profile-menu-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .profile-menu-item:first-child {
            border-radius: 12px 12px 0 0;
        }

        .profile-menu-item:last-child {
            border-radius: 0 0 12px 12px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
            text-decoration: none;
            color: var(--dark-text);
            font-weight: 700;
            font-size: 20px;
        }

        .logo:hover {
            color: var(--primary);
        }

        .header-logo {
            width: 40px;
            height: 40px;
            object-fit: contain;
            flex-shrink: 0;
        }

        .logo-text {
            font-size: 24px;
            font-weight: 400;
            color: white;
            letter-spacing: -0.5px;
            font-family: 'Roboto', 'Arial', sans-serif;
        }

        .beta-badge {
            background: var(--primary);
            color: white;
            font-size: 10px;
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }



        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            text-decoration: none;
            color: var(--dark-text);
        }


        .beta-tag {
            background: var(--primary);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-left: 8px;
        }

        .create-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 18px;
            font-weight: 500;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
            min-width: fit-content;
            backdrop-filter: blur(10px);
        }

        .create-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .material-icons {
            font-size: 18px;
            vertical-align: middle;
        }

        /* Medium screens - prevent overlap between search and create button */
        @media (max-width: 1024px) and (min-width: 769px) {
            .header-center {
                max-width: 400px;
                margin: 0 10px;
            }
            
            .header-right {
                gap: 12px;
                flex-shrink: 0;
            }
            
            .create-btn span:last-child {
                display: none; /* Hide "Create" text, keep icon only */
            }
            
            .profile-btn {
                width: 36px;
                height: 36px;
                flex-shrink: 0;
            }
            
            .mobile-search-btn {
                width: 36px;
                height: 36px;
                flex-shrink: 0;
            }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .header {
                padding: 0 15px;
                height: 60px;
            }

            .header-left {
                gap: 15px;
                flex-shrink: 0;
            }

            .header-center {
                display: none;
            }

            .header-right {
                gap: 12px;
                flex-shrink: 0;
            }

            .mobile-search-btn {
                display: block;
                width: 40px;
                height: 40px;
                flex-shrink: 0;
            }

            .profile-btn {
                width: 40px;
                height: 40px;
                flex-shrink: 0;
            }

            .container {
                padding: 15px;
                margin-top: 60px;
            }

            .breadcrumb-current {
                max-width: 100px;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            .create-btn {
                padding: 6px 12px;
                font-size: 14px;
                min-width: auto;
                flex-shrink: 0;
            }

            .create-btn span:last-child {
                display: inline;
            }
        }

        @media (max-width: 480px) {
            .header {
                padding: 0 10px;
                height: 50px;
            }
            
            .header-left {
                gap: 10px;
                flex-shrink: 0;
            }
            
            .header-right {
                gap: 8px;
                flex-shrink: 0;
            }
            
            .create-btn {
                padding: 4px 8px;
                font-size: 12px;
                flex-shrink: 0;
            }
            
            .create-btn span:last-child {
                display: none;
            }

            .mobile-search-btn {
                width: 32px;
                height: 32px;
                flex-shrink: 0;
            }

            .profile-btn {
                width: 32px;
                height: 32px;
                flex-shrink: 0;
            }

            .logo-text {
                font-size: 18px;
                letter-spacing: -0.3px;
            }

            .beta-badge {
                font-size: 8px;
                padding: 1px 4px;
                margin-left: 4px;
            }

            .container {
                padding: 10px;
                margin-top: 50px;
            }
        }


        /* Info Icon - URL creator와 통일 */
        .info-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--color-secondary);
            color: white;
            border: none;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: var(--space-xs);
            margin-top: 5px;
            transition: var(--transition);
            z-index: 1000;
            position: relative;
        }

        .info-icon:hover {
            background: var(--color-action);
            transform: scale(1.1);
        }

        .info-icon:active {
            transform: scale(0.95);
        }

        /* Apple-style Info Tooltip */
        .apple-tooltip {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #1e1e1e;
            color: #fff;
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #333;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            font-size: 14px;
            line-height: 1.5;
            width: 500px;
            max-width: 90vw;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            white-space: normal;
            margin-top: 10px;
        }
        
        /* Mobile Apple Tooltip */
        @media (max-width: 768px) {
            .apple-tooltip {
                padding: 12px;
                border-radius: 8px;
                width: 300px;
                max-width: 85vw;
                font-size: 10px;
                line-height: 1.3;
                margin-top: 8px;
            }
            
            .apple-tooltip-title {
                font-size: 12px;
                margin-bottom: 4px;
            }
            
            .apple-tooltip-subtitle {
                font-size: 9px;
                margin-top: 2px;
            }
            
            .apple-tooltip-section {
                margin-bottom: 8px;
            }
            
            .apple-tooltip-section-title {
                font-size: 10px;
                margin-bottom: 4px;
            }
            
            .apple-tooltip-section-content {
                font-size: 9px;
                line-height: 1.2;
            }
            
            .apple-tooltip-highlight {
                padding: 8px;
                margin: 8px 0;
                border-radius: 4px;
            }
            
            .apple-tooltip-highlight-title {
                font-size: 10px;
                margin-bottom: 4px;
            }
            
            .apple-tooltip-highlight-content {
                font-size: 9px;
                line-height: 1.2;
            }
        }

        .apple-tooltip.show {
            opacity: 1;
            visibility: visible;
        }

        .apple-tooltip::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 8px solid #1e1e1e;
        }

        .apple-tooltip-header {
            margin-bottom: 16px;
        }

        .apple-tooltip-title {
            color: #ffffff !important;
            font-size: 18px;
            font-weight: 400;
            margin: 0;
            line-height: 1.2;
        }

        .apple-tooltip-subtitle {
            color: #ff3b30;
            font-size: 12px;
            font-weight: 400;
            margin-top: 4px;
            letter-spacing: 0.5px;
        }

        .apple-tooltip-section {
            margin-bottom: 16px;
        }

        .apple-tooltip-section:last-child {
            margin-bottom: 0;
        }

        .apple-tooltip-section-title {
            color: #ffffff !important;
            font-size: 14px;
            font-weight: 400;
            margin: 0 0 8px 0;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .apple-tooltip-section-content {
            color: #cccccc !important;
            font-size: 13px;
            line-height: 1.4;
            margin: 0;
            font-weight: 300;
        }

        .apple-tooltip-highlight {
            background: #2a2a2a;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 12px;
            margin: 12px 0;
        }

        .apple-tooltip-highlight-title {
            color: #ff3b30;
            font-size: 13px;
            font-weight: 400;
            margin: 0 0 6px 0;
        }

        .apple-tooltip-highlight-content {
            color: #cccccc !important;
            font-size: 12px;
            line-height: 1.3;
            margin: 0;
            font-weight: 300;
        }

        /* Create Your Own Button - URL creator와 통일 */
        .create-own-btn {
            background: var(--color-bg-card);
            color: white;
            border: 1px solid var(--color-action);
            border-radius: var(--radius-md);
            padding: var(--space-xs) var(--space-sm);
            font-size: var(--text-sm);
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            box-shadow: var(--shadow-sm);
            backdrop-filter: blur(10px);
            margin-left: 10px;
        }

        .create-own-btn:hover {
            background: var(--color-action);
            color: white;
            transform: scale(1.02);
            box-shadow: var(--shadow-md);
        }

        .create-own-btn:active {
            transform: scale(0.98);
        }

        /* Floating Overlay Settings Panel */
        .overlay-settings-panel {
            position: fixed;
            top: 50%;
            right: var(--space-lg);
            transform: translateY(-50%);
            background: var(--color-bg-card);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-xl);
            padding: var(--space-md);
            box-shadow: var(--shadow-md);
            backdrop-filter: blur(10px);
            z-index: 1000;
            max-width: 280px;
            max-height: 60vh;
            overflow-y: auto;
            transition: all 0.3s ease;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-50%) translateX(100%);
        }

        .overlay-settings-panel.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(-50%) translateX(0);
        }
        
        /* Desktop: Hide overlay settings panel by default */
        @media (min-width: 769px) {
            .overlay-settings-panel {
                display: none !important;
            }
            
            .overlay-settings-panel.show {
                display: block !important;
                opacity: 1;
                visibility: visible;
            }
        }

        .overlay-settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-sm);
            padding-bottom: var(--space-xs);
            border-bottom: 1px solid var(--color-border);
        }

        .overlay-settings-title {
            font-size: var(--text-base);
            font-weight: 600;
            color: var(--color-text-main);
            margin: 0;
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        /* Desktop overlay toggle button - hide on mobile */
        .overlay-toggle-btn {
            display: none;
        }
        
        /* Mobile overlay toggle button */
        @media (max-width: 768px) {
            .overlay-toggle-btn {
                background: none;
                border: none;
                color: rgba(255, 255, 255, 0.7);
                font-size: 12px;
                cursor: pointer;
                padding: 4px 2px;
                margin-left: auto;
                transition: transform 0.2s ease;
                display: flex !important;
                align-items: center;
                justify-content: center;
            }
            
            .overlay-toggle-btn:hover {
                color: rgba(255, 255, 255, 0.9);
            }
            
            .overlay-toggle-btn.collapsed {
                transform: rotate(-90deg);
            }
        }

        .floating-controls h3 {
            margin-top: 0;
            margin-bottom: var(--space-md);
            color: var(--color-text-main);
            font-size: var(--text-lg);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        /* Compact Controls - Only overlay settings */
        .compact-controls {
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
        }

        .compact-controls .input-group {
            margin-bottom: var(--space-sm);
        }

        .compact-controls .input-label {
            font-size: var(--text-xs);
            margin-bottom: var(--space-xs);
        }

        .compact-controls .input {
            padding: var(--space-xs) var(--space-sm);
            font-size: var(--text-sm);
            min-height: 36px;
        }

        .compact-controls .slider-container {
            margin-top: var(--space-xs);
        }

        .compact-controls .slider-value {
            font-size: var(--text-sm);
            min-width: 40px;
        }

        /* Card System */
        .card {
            background: var(--dark-card);
            border-radius: 16px;
            padding: var(--space-lg);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            margin-bottom: var(--space-lg);
        }

        .card-header {
            margin-bottom: var(--space-lg);
            padding-bottom: var(--space-md);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .card-title {
            font-size: var(--text-xl);
            font-weight: 700;
            color: var(--dark-text);
            margin: 0;
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        .card-subtitle {
            font-size: var(--text-base);
            color: var(--dark-text-secondary);
            margin: var(--space-xs) 0 0 0;
        }

        /* Input System */
        .input-group {
            margin-bottom: var(--space-md);
        }

        .input-label {
            display: block;
            margin-bottom: var(--space-xs);
            color: var(--color-text-main);
            font-weight: 600;
            font-size: var(--text-sm);
        }

        .input {
            width: 100%;
            padding: var(--space-sm) var(--space-md);
            background: var(--color-bg-input);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            color: var(--color-text-main);
            font-size: var(--text-base);
            transition: var(--transition);
            min-height: 44px;
            box-sizing: border-box;
        }

        .input:focus {
            outline: none;
            border-color: var(--color-action);
            box-shadow: 0 0 0 3px var(--color-action-light);
        }

        .input:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Button System */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-xs);
            padding: var(--space-sm) var(--space-md);
            border: none;
            border-radius: 20px;
            font-size: var(--text-sm);
            font-weight: 600;
            text-decoration: none;
            cursor: pointer;
            transition: var(--transition);
            user-select: none;
            min-height: 44px;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .btn:active {
            transform: translateY(0);
            box-shadow: var(--shadow-sm);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(193, 42, 31, 0.2);
        }

        .btn-secondary {
            background: var(--color-secondary);
            color: white;
        }

        .btn-secondary:hover {
            background: var(--color-secondary-hover);
        }

        .btn-success {
            background: var(--color-success);
            color: white;
        }

        .btn-warning {
            background: var(--color-warning);
            color: white;
        }

        .btn-info {
            background: var(--color-info);
            color: white;
        }

        /* Button Group */
        .button-group {
            display: flex;
            gap: var(--space-sm);
            margin-top: var(--space-md);
            justify-content: center;
            flex-wrap: wrap;
        }

        /* Video Container - Centered - 터치 보장 */
        .video-container {
            position: relative;
            margin: var(--space-xl) auto var(--space-lg) auto;
            overflow: hidden;
            border-radius: var(--radius-xl);
            background: var(--color-bg-card);
            border: 1px solid var(--color-border);
            max-width: 1200px;
            box-shadow: var(--shadow-md);
            z-index: 100; /* 헤더보다 높은 z-index로 터치 보장 */
        }

        .main-video-box {
            width: 100%;
            background-color: #000;
            border-radius: var(--radius-lg);
            overflow: hidden;
            aspect-ratio: 16 / 9; /* 16:9 비율 유지 */
        }

        .video-title {
            padding: 2.5px var(--space-sm);
            font-weight: 600;
            background: rgba(194, 41, 31, 0.9);
            border-bottom: 1px solid var(--color-border);
            color: white;
            font-size: var(--text-base);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .video-title-text {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }

        /* Toggle Switch for Settings - Recorder 스타일 적용 */
        .toggle-switch {
            margin-left: auto;
            display: flex;
            align-items: center;
        }

        .toggle-switch input {
            display: none;
        }

        .toggle-slider {
            position: relative;
            width: 40px;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 4px;
        }

        .toggle-slider:before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transition: var(--transition);
        }

        .toggle-text-on,
        .toggle-text-off {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 8px;
            font-weight: bold;
            color: white;
            transition: var(--transition);
            white-space: nowrap;
        }

        .toggle-text-on {
            left: 6px;
            opacity: 0;
        }

        .toggle-text-off {
            right: 6px;
            opacity: 1;
        }

        .toggle-switch input:checked + .toggle-slider .toggle-text-on {
            opacity: 1;
        }

        .toggle-switch input:checked + .toggle-slider .toggle-text-off {
            opacity: 0;
        }

        .toggle-switch input:checked + .toggle-slider {
            background: var(--color-action);
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }

        #reaction-youtube-container {
            width: 100%;
            height: 100%; /* 부모의 aspect-ratio를 따름 */
            background-color: #000;
            display: flex;
            align-items: flex-start; /* 맨 위로 붙이기 */
            justify-content: center;
        }

        #reaction-youtube-container iframe {
            width: 100% !important;
            height: 100% !important;
        }

        /* Overlay styles - 터치 보장 */
        #youtube-container {
            position: absolute;
            background-color: #000;
            border-radius: var(--radius-md);
            overflow: hidden;
            z-index: 200; /* 헤더와 비디오 컨테이너보다 높은 z-index */
            box-shadow: var(--shadow-lg);
            width: 50%;
            transition: all 0.3s ease;
            aspect-ratio: 16 / 9;
        }
        
        /* 모바일에서 오버레이 영상 성능 최적화 */
        @media (max-width: 768px) {
            #youtube-container {
                /* GPU 가속 활성화 */
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
                /* 하드웨어 가속 */
                will-change: transform;
            }
            
            #youtube-container iframe {
                /* 모바일에서 iframe 최적화 */
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }
        }

        #youtube-container iframe {
            width: 100% !important;
            height: 100% !important;
        }

        #youtube-container.overlay-top-right {
            top: 3% !important;        /* 모든 화면에서 3% 강제 적용 */
            right: 2% !important;      /* 모든 화면에서 2% 강제 적용 */
            height: auto !important;   /* 16:9 비율 보장 */
        }

        #youtube-container.overlay-top-left {
            top: 3% !important;        /* 모든 화면에서 3% 강제 적용 */
            left: 2% !important;       /* 모든 화면에서 2% 강제 적용 */
            height: auto !important;   /* 16:9 비율 보장 */
        }

        #youtube-container.overlay-bottom-right {
            bottom: 8% !important;     /* 모든 화면에서 8% 강제 적용 */
            right: 2% !important;      /* 모든 화면에서 2% 강제 적용 */
            height: auto !important;   /* 16:9 비율 보장 */
        }

        #youtube-container.overlay-bottom-left {
            bottom: 8% !important;     /* 모든 화면에서 8% 강제 적용 */
            left: 2% !important;       /* 모든 화면에서 2% 강제 적용 */
            height: auto !important;   /* 16:9 비율 보장 */
        }

        /* 모든 화면에서 동일한 퍼센트 기반 위치 사용 - 모바일과 데스크탑 통일 */

        /* Quick Playback Controls - Right below video */
        .quick-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-sm);
            flex-wrap: wrap;
            margin-top: var(--space-xs);
        }

        .quick-controls .btn {
            min-width: 80px;
            padding: 6px 12px;
            font-size: var(--text-sm);
            font-weight: 600;
            border-radius: var(--radius-md);
            transition: all 0.15s ease;
            border: 1px solid rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(8px);
            position: relative;
            overflow: hidden;
        }

        .quick-controls .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .quick-controls .btn:hover::before {
            left: 100%;
        }

        .quick-controls .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .quick-controls .btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .quick-controls .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .quick-controls .btn:disabled::before {
            display: none;
        }

        /* Help button specific style */
        .quick-controls .btn-info {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #ffc107;
            color: var(--color-text-main);
        }

        .quick-controls .btn-info:hover {
            background: rgba(255, 193, 7, 0.1);
            border-color: #ffd54f;
            color: #ffc107;
        }

        /* Resync button in quick controls */
        .quick-controls .inline-btn {
            align-self: flex-end;
            margin-top: 5px;
        }

        /* Beta Version Notice */
        .beta-notice {
            background: rgba(255, 193, 7, 0.08);
            border: 1px solid rgba(255, 193, 7, 0.2);
            border-radius: var(--radius-lg);
            margin-top: var(--space-md);
            padding: var(--space-md) var(--space-lg);
            backdrop-filter: blur(15px);
            box-shadow: var(--shadow-sm);
        }

        .beta-notice-content {
            display: flex;
            align-items: flex-start;
            gap: var(--space-md);
        }

        .beta-notice-icon {
            font-size: var(--text-xl);
            margin-top: 2px;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3));
        }

        .beta-notice-text {
            color: var(--dark-text);
            font-size: var(--text-sm);
            line-height: 1.6;
            font-weight: 400;
        }

        .beta-notice-text strong {
            color: #ffc107;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        /* Help FAQ Styles */
        .help-faq {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: var(--radius-xl);
            margin-top: var(--space-md);
            box-shadow: var(--shadow-lg);
            backdrop-filter: blur(15px);
            max-height: 70vh;
            overflow-y: auto;
        }

        .help-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-xs) var(--space-sm);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(255, 255, 255, 0.05);
            border-radius: var(--radius-xl) var(--radius-xl) 0 0;
        }

        .help-header h3 {
            margin: 0;
            color: white;
            font-size: var(--text-base);
            font-weight: 700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        /* Mobile Help FAQ Styles - New Design */
        @media (max-width: 768px) {
            .help-faq {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                max-height: 100vh;
                margin: 0;
                border-radius: 0;
                background: rgba(0, 0, 0, 0.95);
                backdrop-filter: blur(20px);
                z-index: 2000;
                overflow-y: auto;
            }
            
            .help-header {
                position: sticky;
                top: 0;
                background: rgba(0, 0, 0, 0.9);
                padding: 8px 12px;
                border-radius: 0;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            
            .help-header h3 {
                font-size: 14px;
                margin: 0;
            }
            
            .help-close-btn {
                width: 28px;
                height: 28px;
                font-size: 16px;
                background: rgba(255, 255, 255, 0.1);
                border-radius: 50%;
            }
            
            .faq-content {
                padding: 12px;
            }
            
            .faq-section {
                margin-bottom: 8px;
                padding: 8px;
                border-radius: 8px;
                background: rgba(255, 255, 255, 0.05);
                border: 1px solid rgba(255, 255, 255, 0.1);
            }
            
            .faq-section h4 {
                font-size: 12px;
                margin-bottom: 4px;
                color: var(--color-action);
            }
            
            .faq-section p,
            .faq-section li {
                font-size: 11px;
                line-height: 1.4;
                margin-bottom: 2px;
            }
            
            .faq-section ul {
                padding-left: 12px;
                margin: 4px 0;
            }
            
            .faq-section strong {
                color: var(--color-action);
            }
        }

        .help-close-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: var(--color-text-sub);
            font-size: var(--text-xl);
            cursor: pointer;
            padding: var(--space-xs);
            border-radius: var(--radius-sm);
            transition: var(--transition);
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .help-close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: var(--color-text-main);
            transform: scale(1.1);
        }

        .faq-content {
            padding: var(--space-sm);
            color: white;
        }

        .faq-content:first-child {
            padding-top: 0;
        }

        .faq-content .faq-section:first-child {
            padding-top: 0 !important;
            margin-top: 0 !important;
        }

        .faq-content .faq-section:first-child h4 {
            margin-top: var(--space-sm) !important;
            padding-top: var(--space-sm) !important;
        }

        .faq-content .faq-section:first-child .faq-item:first-child {
            margin-top: 0 !important;
            padding-top: 0 !important;
        }

        .faq-section {
            margin-bottom: var(--space-xs);
            padding: var(--space-xs);
            background: rgba(255, 255, 255, 0.03);
            border-radius: var(--radius-md);
            border: 1px solid rgba(255, 255, 255, 0.05);
            color: white;
        }

        .faq-section:first-child {
            padding-top: 0 !important;
            margin-top: 0 !important;
        }

        .faq-section:first-child .faq-item:first-child {
            margin-top: 0 !important;
            padding-top: 0 !important;
        }

        .faq-content .faq-section:first-child {
            padding-top: 0 !important;
            margin-top: 0 !important;
        }

        .faq-content .faq-section:first-child .faq-item:first-child {
            margin-top: 0 !important;
            padding-top: 0 !important;
        }

        .faq-section:last-child {
            margin-bottom: 0;
        }

        .faq-section h4 {
            color: white;
            font-size: var(--text-base);
            margin-bottom: var(--space-xs);
            margin-top: 0;
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            font-weight: 700;
            padding: var(--space-xs) var(--space-sm);
            background: rgba(255, 193, 7, 0.1);
            border-radius: var(--radius-sm);
            border: 1px solid rgba(255, 193, 7, 0.2);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .faq-section p {
            color: var(--color-text-main);
            font-size: var(--text-sm);
            line-height: 1.4;
            margin-bottom: var(--space-xs);
            font-weight: 400;
        }

        .faq-section ul {
            color: var(--color-text-main);
            font-size: var(--text-sm);
            line-height: 1.4;
            margin-left: var(--space-sm);
            margin-bottom: var(--space-xs);
        }

        .faq-section li {
            margin-bottom: var(--space-xs);
            padding-left: var(--space-xs);
            color: white;
        }
        
        .faq-section p {
            color: white;
        }

        .faq-item {
            margin-bottom: var(--space-xs);
            padding: var(--space-xs);
            background: rgba(255, 255, 255, 0.05);
            border-radius: var(--radius-sm);
            border-left: 3px solid var(--color-action);
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: white;
        }

        .faq-item:last-child {
            margin-bottom: 0;
        }

        .faq-item h5 {
            color: #ffd54f;
            font-size: var(--text-sm);
            margin-bottom: var(--space-xs);
            font-weight: 600;
            text-shadow: 0 1px 1px rgba(0, 0, 0, 0.3);
        }
        
        .faq-item p,
        .faq-item li {
            color: white;
        }

        .inline-btn {
            background: linear-gradient(135deg, #ffc107, #ffd54f);
            color: #333;
            border: none;
            padding: 3px 8px;
            border-radius: var(--radius-sm);
            font-size: 0.7em;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            box-shadow: var(--shadow-sm);
            position: relative;
        }

        .inline-btn:hover {
            background: linear-gradient(135deg, #ffd54f, #ffc107);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .inline-btn:hover::after {
            content: "Beta - Not perfect yet";
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7em;
            white-space: nowrap;
            z-index: 9999;
        }

        /* New compact issue box styles */
        .compact-issue-box {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--radius-sm);
            padding: var(--space-sm);
            margin-bottom: var(--space-sm);
            border-left: 3px solid var(--color-action);
        }

        .compact-issue-box h5 {
            color: #ffd54f;
            font-size: var(--text-sm);
            margin: 0 0 var(--space-xs) 0;
            font-weight: 600;
            text-shadow: 0 1px 1px rgba(0, 0, 0, 0.3);
        }

        .compact-issue-box p {
            color: var(--color-text-main);
            font-size: var(--text-sm);
            line-height: 1.4;
            margin: 0 0 var(--space-xs) 0;
            font-weight: 400;
        }

        .compact-issue-box ul {
            color: var(--color-text-main);
            font-size: var(--text-sm);
            line-height: 1.4;
            margin: 0 0 0 var(--space-sm);
            padding: 0;
        }

        .compact-issue-box li {
            margin-bottom: 4px;
            padding-left: var(--space-xs);
        }

        /* Controls Grid */
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: var(--space-lg);
            margin-bottom: var(--space-lg);
            width: 100%;
            box-sizing: border-box;
        }

        /* Source Selector */
        .source-selector {
            display: flex;
            gap: var(--space-md);
            margin-bottom: var(--space-md);
            background: var(--color-bg-input);
            padding: var(--space-sm);
            border-radius: var(--radius-md);
        }

        .source-selector label {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: var(--space-xs) var(--space-sm);
            border-radius: var(--radius-sm);
            transition: var(--transition);
            font-weight: 500;
        }

        .source-selector label:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .source-selector input[type="radio"] {
            margin-right: var(--space-xs);
            accent-color: var(--color-action);
        }

        /* Slider System */
        .slider-container {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            margin-top: var(--space-sm);
        }

        .slider-container input[type="range"] {
            flex-grow: 1;
            height: 8px;
            background: var(--color-secondary);
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--color-action);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: var(--shadow-sm);
        }

        .slider-value {
            min-width: 60px;
            text-align: center;
            font-weight: bold;
            color: var(--color-action);
            font-size: var(--text-lg);
        }

        /* Status and Messages */
        .status {
            margin-top: var(--space-md);
            font-style: italic;
            color: var(--color-text-sub);
            text-align: center;
            padding: var(--space-sm);
            background: var(--color-bg-input);
            border-radius: var(--radius-md);
            font-weight: 500;
        }

        .message {
            padding: var(--space-md);
            margin-top: var(--space-md);
            border-radius: var(--radius-md);
            display: none;
            font-weight: 500;
        }

        .message.error {
            background: rgba(244, 67, 54, 0.1);
            border: 1px solid var(--color-error);
            color: var(--color-error);
        }

        .message.success {
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid var(--color-success);
            color: var(--color-success);
        }

        .message.info {
            background: rgba(33, 150, 243, 0.1);
            border: 1px solid var(--color-info);
            color: var(--color-info);
        }

        /* Debug Info */
        .debug-info {
            background: var(--color-bg-card);
            padding: var(--space-lg);
            border-radius: var(--radius-lg);
            margin-bottom: var(--space-lg);
            border: 1px solid var(--color-border);
        }

        .debug-info h3 {
            margin-top: 0;
            margin-bottom: var(--space-md);
            color: var(--color-text-main);
            font-size: var(--text-lg);
        }

        #debug-content {
            font-family: 'Courier New', monospace;
            font-size: var(--text-sm);
            max-height: 300px;
            overflow-y: auto;
            background: var(--color-bg-input);
            padding: var(--space-md);
            border-radius: var(--radius-md);
            border: 1px solid var(--color-border);
            color: var(--color-text-sub);
            line-height: 1.4;
        }

        /* Footer */
        footer {
            text-align: center;
            margin-top: var(--space-xl);
            padding-top: var(--space-lg);
            border-top: 1px solid var(--color-border);
            font-size: var(--text-sm);
            color: var(--color-text-muted);
        }

                 /* Responsive Design */
         @media (max-width: 768px) {
             .container {
                 padding: 0;
                 max-width: 100%;
             }
             
             /* Hide overlay toggle and settings button on mobile */
             .overlay-toggle-desktop {
                 display: none !important;
             }
             
             .quick-controls .btn[data-overlay-settings] {
                 display: none !important;
             }
            
            
            .create-own-btn {
                font-size: var(--text-xs);
                padding: 4px 8px;
            }
            
            
            /* Video Container Mobile Optimization */
            .video-container {
                margin-bottom: var(--space-md);
            }
            
            .main-video-box {
                border-radius: var(--radius-sm);
            }
            
            .video-title {
                padding: var(--space-sm);
                flex-direction: column;
                gap: var(--space-xs);
            }
            
            .video-title-text {
                font-size: var(--text-sm);
            }
            
            #reaction-youtube-container, 
            #reaction-youtube-container iframe {
                height: 100%; /* 부모의 aspect-ratio를 따름 */
                border-radius: var(--radius-sm);
            }
            
            /* Overlay Mobile Optimization - 위치는 #youtube-container에서 통일 관리 */
            /* 크기와 비율만 모바일 최적화 */
            
            /* Controls Mobile Optimization */
            .quick-controls {
                flex-direction: row;
                flex-wrap: wrap;
                gap: var(--space-xs);
                margin-bottom: var(--space-md);
            }

            .quick-controls .btn {
                flex: 1;
                min-width: 80px;
                padding: var(--space-sm) var(--space-xs);
                font-size: var(--text-sm);
                min-height: 44px; /* Touch-friendly */
                order: 0;
            }
            
            .inline-btn {
                padding: 4px 6px;
                font-size: 9px;
                min-height: 24px;
                border-radius: 8px;
                order: 0;
            }
            
                         /* Overlay Settings Panel Mobile - Inside quick-controls */
             .overlay-settings-panel {
                 position: static;
                 top: auto;
                 right: auto;
                 transform: none;
                 background: transparent;
                 backdrop-filter: none;
                 border-radius: 0;
                 padding: 0;
                 box-shadow: none;
                 border: none;
                 z-index: auto;
                 max-width: none;
                 max-height: none;
                 overflow-y: visible;
                 transition: none;
                 opacity: 1;
                 visibility: visible;
                 margin: var(--space-sm) 0 0 0;
                 width: 100%;
                 order: 1;
                 display: block !important;
             }
            
                         .overlay-settings-panel.show {
                 display: none;
             }
             
             /* Ensure overlay controls are properly styled on mobile */
             .overlay-settings-panel .compact-controls {
                 grid-template-columns: 1fr 1fr;
                 gap: var(--space-sm);
                 width: 100%;
                 padding: var(--space-sm);
                 background: rgba(255, 255, 255, 0.05);
                 border-radius: var(--radius-md);
                 border: 1px solid rgba(255, 255, 255, 0.1);
                 box-sizing: border-box;
                 overflow: hidden;
                 display: grid; /* Default display, but can be overridden by JavaScript */
             }
            
                         .overlay-settings-header {
                 display: flex;
                 justify-content: space-between;
                 align-items: center;
                 margin-bottom: var(--space-xs);
                 padding: var(--space-xs) 0;
                 border-bottom: 1px solid rgba(255, 255, 255, 0.2);
             }
            
                         .overlay-settings-title {
                 font-size: var(--text-xs);
                 font-weight: 600;
                 color: rgba(255, 255, 255, 0.9);
                 margin: 0;
                 display: flex;
                 align-items: center;
                 gap: var(--space-xs);
                 cursor: pointer;
                 flex: 1;
                 padding: 2px 0;
             }
             
             /* Show toggle button on mobile */
             .overlay-toggle-btn {
                 display: flex !important;
                 cursor: pointer;
                 user-select: none;
                 -webkit-tap-highlight-color: transparent;
             }
             
             /* Show overlay settings panel on mobile */
             .overlay-settings-panel {
                 display: block !important;
                 max-width: none;
                 max-height: none;
                 overflow-y: visible;
                 transition: none;
                 opacity: 1;
                 visibility: visible;
                 margin: var(--space-sm) 0 0 0;
                 width: 100%;
                 order: 1;
             }
             
             /* Show controls when expanded on mobile */
             .compact-controls {
                 display: grid;
                 grid-template-columns: 1fr 1fr;
                 gap: var(--space-sm);
                 width: 100%;
                 padding: var(--space-sm);
                 background: rgba(255, 255, 255, 0.05);
                 border-radius: var(--radius-md);
                 border: 1px solid rgba(255, 255, 255, 0.1);
             }
             
             /* Mobile: Hide controls by default */
             @media (max-width: 768px) {
                 .compact-controls {
                     display: none;
                 }
             }
            
                         .input-group {
                 margin-bottom: 0;
                 padding: 2px;
                 background: rgba(255, 255, 255, 0.03);
                 border-radius: var(--radius-sm);
                 border: 1px solid rgba(255, 255, 255, 0.08);
                 display: flex;
                 flex-direction: column;
                 align-items: stretch;
                 gap: 2px;
             }
            
                         .input-group label {
                 font-size: 10px;
                 margin-bottom: 0;
                 padding: 0;
                 color: rgba(255, 255, 255, 0.7);
                 white-space: nowrap;
                 font-weight: 400;
                 text-transform: uppercase;
                 letter-spacing: 0.5px;
             }
            
                         .input-group input,
             .input-group select {
                 padding: 2px 4px;
                 font-size: var(--text-xs);
                 min-height: 20px;
                 background: rgba(255, 255, 255, 0.1);
                 border: 1px solid rgba(255, 255, 255, 0.2);
                 border-radius: var(--radius-sm);
                 color: white;
                 width: 100%;
                 position: relative;
                 z-index: 1;
             }
            
                         .slider-container {
                 margin-top: 0;
                 display: flex;
                 align-items: center;
                 gap: 2px;
                 width: 100%;
             }
            
                         .slider-container input[type="range"] {
                 min-height: 24px;
                 width: 100%;
                 background: rgba(255, 255, 255, 0.2);
                 border-radius: 2px;
                 flex: 1;
             }
             
             .slider-container input[type="range"]::-webkit-slider-thumb {
                 -webkit-appearance: none;
            appearance: none;
                 width: 16px;
                 height: 16px;
                 background: var(--color-action);
                 border-radius: 50%;
                 cursor: pointer;
                 box-shadow: var(--shadow-sm);
             }
             
             .slider-value {
                 font-size: var(--text-xs);
                 min-width: 30px;
                 color: rgba(255, 255, 255, 0.8);
                 display: none;
             }
             
             /* Hide slider values on mobile to prevent horizontal scroll */
             @media (max-width: 768px) {
                 .slider-value {
                     display: none;
                 }
             }
            
            /* Beta Notice Mobile */
            .beta-notice {
                margin-bottom: var(--space-md);
            }
            
            .beta-notice-content {
                padding: var(--space-sm);
                flex-direction: column;
                gap: var(--space-xs);
            }
            
            .beta-notice-text {
                font-size: var(--text-sm);
                line-height: 1.4;
            }
            
            /* Floating Controls Mobile */
            .floating-controls {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                top: auto;
                transform: none;
                border-radius: var(--radius-lg) var(--radius-lg) 0 0;
                max-width: none;
                max-height: 60vh;
            }

            .floating-toggle {
                position: absolute;
                top: -40px;
                left: 50%;
                transform: translateX(-50%);
                border-radius: var(--radius-md) var(--radius-md) 0 0;
                min-height: 44px;
                min-width: 44px;
            }

            .floating-controls.collapsed {
                transform: translateY(calc(100% - 50px));
            }

            .floating-controls.collapsed .floating-toggle {
                border-radius: var(--radius-md);
            }
            
            /* Status Bar Mobile */
            .status-bar {
                flex-direction: column;
                align-items: stretch;
                padding: var(--space-sm);
                font-size: var(--text-sm);
            }
            
            /* General Mobile Improvements */
            .btn {
                min-height: 40px; /* Touch-friendly minimum */
                font-size: 10px;
            }
            
            /* Unified font sizes for mobile */
            .btn,
            .inline-btn,
            .help-header h3,
            .faq-section h4,
            .apple-tooltip-title,
            .apple-tooltip-section-title,
            .apple-tooltip-highlight-title {
                font-size: 10px !important;
            }
            
            .faq-section p,
            .faq-section li,
            .apple-tooltip-section-content,
            .apple-tooltip-highlight-content,
            .apple-tooltip-subtitle {
                font-size: 9px !important;
            }
            
            .controls-grid {
                grid-template-columns: 1fr;
                gap: var(--space-sm);
            }
            
            .button-group {
                flex-direction: column;
                gap: var(--space-xs);
            }
            
            .source-selector {
                flex-direction: column;
                gap: var(--space-sm);
            }
        }
        
                 /* Extra Small Mobile Devices */
         @media (max-width: 480px) {
             
             
             .breadcrumb {
                 font-size: 10px;
                 gap: 4px;
             }

             .breadcrumb-current {
                 max-width: 80px;
                 overflow: hidden;
                 text-overflow: ellipsis;
                 white-space: nowrap색이랑 toggle 
             }
             
             .header-right .create-btn {
                 display: none;
             }
             
             /* Compact overlay settings for very small screens */
             .overlay-settings-panel {
                 margin: var(--space-sm) 0;
             }
             
             .input-group {
                 margin-bottom: 0;
                 padding: 2px;
                 background: rgba(255, 255, 255, 0.05);
                 border-radius: var(--radius-sm);
                 border: 1px solid rgba(255, 255, 255, 0.1);
                 display: flex;
                 flex-direction: column;
                 align-items: stretch;
                 gap: 2px;
             }
             
             .compact-controls {
                 display: grid;
                 grid-template-columns: 1fr 1fr;
                 gap: var(--space-sm);
                 width: 100%;
                 padding: var(--space-sm);
                 background: rgba(255, 255, 255, 0.05);
                 border-radius: var(--radius-md);
                 border: 1px solid rgba(255, 255, 255, 0.1);
                 box-sizing: border-box;
                 overflow: hidden;
             }
             
             .input-group label {
                 font-size: 9px;
                 margin-bottom: 0;
                 padding: 0;
                 color: rgba(255, 255, 255, 0.7);
                 white-space: nowrap;
                 font-weight: 400;
                 text-transform: uppercase;
                 letter-spacing: 0.5px;
             }
             
             .input-group input,
             .input-group select {
                 font-size: var(--text-xs);
                 min-height: 18px;
                 padding: 2px 3px;
                 background: rgba(255, 255, 255, 0.1);
                 border: 1px solid rgba(255, 255, 255, 0.2);
                 border-radius: var(--radius-sm);
                 color: white;
                 width: 100%;
                 position: relative;
                 z-index: 1;
             }
             
             .slider-container {
                 margin-top: 0;
                 display: flex;
                 align-items: center;
                 gap: 2px;
                 width: 100%;
             }
             
             .slider-container input[type="range"] {
                 min-height: 20px;
                 width: 100%;
                 background: rgba(255, 255, 255, 0.2);
                 border-radius: 2px;
                 flex: 1;
             }
             
             .slider-container input[type="range"]::-webkit-slider-thumb {
                 width: 12px;
                 height: 12px;
             }
             
             .slider-value {
                 font-size: var(--text-xs);
                 min-width: 25px;
                 color: rgba(255, 255, 255, 0.8);
                 display: none;
             }
            
            
            
            .quick-controls {
                flex-direction: column;
            }
            
            .quick-controls .btn {
                width: 100%;
            }
            
            /* 오버레이 크기만 설정 - 위치는 #youtube-container에서 통일 관리 */
            /* width와 height만 설정하여 위치 충돌 방지 */
        }
        
        /* YouTube-style Layout */
        .youtube-layout {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            gap: 24px;
        }

        .main-content {
            flex: 1;
            min-width: 0;
        }

        .sidebar {
            width: 350px;
            flex-shrink: 0;
            max-height: calc(100vh - 60px);
            overflow-y: auto;
        }

        .sidebar-content {
            padding: 0;
        }

        /* Sidebar Content */
        .sidebar-tabs {
            display: flex;
            margin-bottom: 16px;
            padding: 0 8px;
        }

        .sidebar-tab {
            flex: 1;
            padding: 8px 12px;
            background: none;
            border: none;
            color: var(--dark-text-secondary);
            font-size: 14px;
            font-weight: 400;
            cursor: pointer;
            transition: color 0.2s ease;
            border-radius: 18px;
            margin-right: 4px;
        }

        .sidebar-tab:hover {
            color: var(--dark-text);
            background: rgba(255, 255, 255, 0.1);
        }

        .sidebar-tab.active {
            color: var(--dark-text);
            background: rgba(255, 255, 255, 0.15);
            font-weight: 500;
        }

        .sidebar-section {
            margin-bottom: 0;
            padding: 0 8px;
        }

        .sidebar-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--dark-text);
            margin-bottom: 12px;
            padding: 0 8px;
        }

        .video-item {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            padding: 0;
            cursor: pointer;
            transition: none;
        }

        .video-item:hover .video-item-title {
            color: var(--primary);
        }

        .video-thumbnail {
            width: 168px;
            height: 94px;
            background: #000;
            border-radius: 8px;
            flex-shrink: 0;
            position: relative;
            overflow: hidden;
        }

        .video-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .video-duration {
            position: absolute;
            bottom: 4px;
            right: 4px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 12px;
            padding: 2px 4px;
            border-radius: 4px;
        }

        .video-info {
            flex: 1;
            min-width: 0;
        }

        .video-item-title {
            font-size: 14px;
            font-weight: 500;
            color: var(--dark-text);
            line-height: 1.3;
            margin-bottom: 6px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .video-item-channel {
            font-size: 12px;
            color: var(--dark-text-secondary);
            margin-bottom: 2px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .video-item-stats {
            font-size: 12px;
            color: var(--dark-text-secondary);
            line-height: 1.2;
        }

        .channel-verified {
            width: 12px;
            height: 12px;
            background: var(--dark-text-secondary);
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: var(--dark-bg);
        }






        /* YouTube-style Video Info Section */
        .video-info-section {
            background: var(--dark-bg);
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .video-title-section {
            margin-bottom: 12px;
        }

        .video-title-main {
            font-size: 20px;
            font-weight: 600;
            color: var(--dark-text);
            margin-bottom: 8px;
            line-height: 1.3;
        }

        .video-stats {
            display: flex;
            align-items: center;
            gap: 16px;
            font-size: 14px;
            color: var(--dark-text-secondary);
            margin-bottom: 16px;
        }

        .video-actions-section {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
        }

        .channel-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .channel-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary) 0%, #ff6b6b 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            font-weight: 700;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .channel-details {
            flex: 1;
        }

        .channel-name {
            font-size: 16px;
            font-weight: 600;
            color: var(--dark-text);
            margin-bottom: 4px;
        }

        .subscriber-count {
            font-size: 14px;
            color: var(--dark-text-secondary);
        }

        .action-buttons {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .action-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--dark-text);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 14px;
            font-weight: 500;
        }

        .action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .action-btn.subscribe-btn {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
        }

        .action-btn.subscribe-btn:hover {
            background: var(--primary-dark);
            border-color: var(--primary-dark);
        }

        .action-btn.subscribed {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            color: var(--dark-text);
        }

        .action-btn.liked {
            color: var(--primary);
            background: rgba(193, 42, 31, 0.15);
            border-color: rgba(193, 42, 31, 0.3);
        }

        .action-btn.bookmarked {
            color: #ffd700;
            background: rgba(255, 215, 0, 0.15);
            border-color: rgba(255, 215, 0, 0.3);
        }

        .action-btn .material-icons {
            font-size: 18px;
        }

        .video-description {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 16px;
            margin-top: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .description-text {
            font-size: 14px;
            color: var(--dark-text-secondary);
            line-height: 1.6;
            word-wrap: break-word;
            white-space: pre-wrap;
        }
        
        .description-text:empty::before {
            content: "No description available.";
            color: var(--dark-text-muted);
            font-style: italic;
        }

        /* Mobile responsive for video info section */
        @media (max-width: 768px) {
            .youtube-layout {
                flex-direction: column;
                gap: 0;
            }

            .sidebar {
                display: none;
            }

            .video-info-section {
                padding: 16px;
                margin: 0;
                max-width: 100%;
            }

            .video-title-main {
                font-size: 18px;
            }

            .video-actions-section {
                flex-direction: column;
                gap: 12px;
                align-items: flex-start;
            }

            .action-buttons {
                width: 100%;
                justify-content: flex-start;
            }

            .action-btn {
                flex: 1;
                justify-content: center;
            }

            .channel-info {
                width: 100%;
            }
        }

        /* Mobile Video UX Enhancements */
        @media (max-width: 768px) {
            /* Fullscreen-like experience */
        .video-container {
            position: relative;
            background: #000;
            border-radius: 0;
            margin: 0;
            padding: 0;
            box-shadow: none;
            width: 100vw;
            margin-left: calc(-50vw + 50%);
        }
            
            .main-video-box {
                border-radius: 0;
                background: #000;
            }
            
            #reaction-youtube-container, 
            #reaction-youtube-container iframe {
                height: 100%; /* 부모의 aspect-ratio를 따름 */
                border-radius: 0;
                background: #000;
            }
            
            /* Mobile controls between video and footer */
            .quick-controls {
                position: static;
                transform: none;
                background: rgba(0, 0, 0, 0.9);
                backdrop-filter: blur(10px);
                border-radius: var(--radius-md);
                padding: var(--space-sm);
                gap: var(--space-xs);
                margin: var(--space-md) 0;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                border: 1px solid rgba(255, 255, 255, 0.1);
                display: flex;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
                align-items: center;
            }
            
            .quick-controls .btn {
                border-radius: 15px;
                min-width: 40px;
                height: 40px;
                padding: 0;
                font-size: 12px;
                background: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: white;
            }
            
            .quick-controls .btn:hover {
                background: rgba(255, 255, 255, 0.2);
            }
            
            .quick-controls .btn:active {
                transform: scale(0.95);
            }
            
            /* Hide controls when not needed */
            .quick-controls.hidden {
                opacity: 0;
                pointer-events: none;
                transform: translateY(20px);
            }
            
            /* Video title overlay (like Netflix) */
            .video-title {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                background: linear-gradient(180deg, rgba(0,0,0,0.7) 0%, transparent 100%);
                padding: 20px var(--space-sm) var(--space-sm);
                z-index: 10;
                opacity: 0;
                transition: opacity 0.3s ease;
            }
            
            .video-container:hover .video-title {
                opacity: 1;
            }
            
            /* Gesture-friendly overlay controls */
            .overlay-settings-panel {
                background: rgba(0, 0, 0, 0.95);
                backdrop-filter: blur(20px);
            }
            
            .overlay-settings-header {
                background: rgba(255, 255, 255, 0.1);
                border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            /* Swipe-friendly sliders */
            .slider-container input[type="range"] {
                -webkit-appearance: none;
            appearance: none;
                height: 6px;
                background: rgba(255, 255, 255, 0.2);
                border-radius: 3px;
                outline: none;
            }
            
            .slider-container input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
            appearance: none;
                width: 20px;
                height: 20px;
                background: var(--color-action);
                border-radius: 50%;
                cursor: pointer;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            }
            
            
            .beta-tag {
                font-size: 8px;
                padding: 1px 3px;
                flex-shrink: 0;
            }
            
            .create-own-btn {
                font-size: 8px;
                padding: 1px 4px;
                border-radius: 8px;
                flex-shrink: 0;
            }
            
            .info-icon {
                width: 14px;
                height: 14px;
                font-size: 8px;
                border-radius: 50%;
                flex-shrink: 0;
            }
            
            
                         /* Beta notice less intrusive */
             .beta-notice {
                 background: rgba(0, 0, 0, 0.9);
                 backdrop-filter: blur(10px);
                 border-radius: var(--radius-md);
                 border: 1px solid rgba(255, 255, 255, 0.1);
                 margin: var(--space-sm) 0;
                 padding: var(--space-xs);
             }
             
             /* Mobile Beta Notice - Hide icon and modify text */
             .beta-notice .beta-notice-icon {
                 display: none;
             }
             
             .beta-notice .beta-notice-text {
                 font-size: 11px;
                 line-height: 1.3;
                 text-align: center;
             }
             
             /* Mobile Beta Notice Text Switching */
             .beta-notice .desktop-beta-text {
                 display: none !important;
             }
             
             .beta-notice .mobile-beta-text {
                 display: block !important;
             }
            
            .beta-notice-content {
                padding: var(--space-xs);
            }
            
            .beta-notice-text {
                font-size: 11px;
                line-height: 1.3;
            }
            
            /* Status bar floating */
            .status-bar {
                position: fixed;
                top: 15px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.8);
                backdrop-filter: blur(10px);
                border-radius: 15px;
                padding: 6px 12px;
                font-size: 11px;
                z-index: 1000;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }
            
            /* Overlay positioning for better visibility */
            .overlay-top-right,
            .overlay-top-left {
                top: 70px !important;
            }
            
            .overlay-bottom-right,
            .overlay-bottom-left {
                bottom: 120px !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <div class="header-left">
                <button class="menu-btn" onclick="toggleSidebar()">
                    <span class="material-icons">menu</span>
                </button>
                <a href="/react-central.html" class="logo">
                    <img src="./logo/whitered_mini.png" alt="React Central" class="header-logo">
                    <span class="logo-text">ReactCentral</span>
                    <span class="beta-badge">Beta</span>
                </a>
            </div>

            <div class="header-center">
                <div class="search-container">
                    <input type="text" class="search-bar" placeholder="Search" id="searchInput">
                    <button class="search-btn" onclick="performSearch()">
                        <span class="material-icons">search</span>
                    </button>
                </div>
            </div>

            <div class="header-right">
                <button class="mobile-search-btn" id="mobileSearchBtn" onclick="toggleMobileSearch()">
                    <span class="material-icons">search</span>
                </button>
                <a href="/studio.html" class="create-btn">
                    <span class="material-icons">add</span>
                    <span>Create</span>
                </a>
                <button class="profile-btn" id="profileBtn" onclick="toggleProfileMenu()">
                    <span class="material-icons">account_circle</span>
                </button>
                <div class="profile-menu" id="profileMenu" style="display: none;">
                    <!-- 동적으로 로그인 상태에 따라 업데이트됨 -->
                </div>
            </div>
        </header>



        <!-- Message Display -->
        <div class="message" id="message"></div>
        

        
        <!-- Help FAQ -->
        <div class="help-faq" id="helpFaq" style="display: none;">
            <div class="help-header">
                <h3>❓ Help & FAQ</h3>
                <button class="help-close-btn" id="helpCloseBtn">×</button>
            </div>
            
            <div class="faq-content">
                <div class="faq-section">
                    <h4>⚠️ Common Issues & Solutions</h4>
                    <div class="compact-issue-box">
                        <h5>Jump to timestamp doesn't work properly</h5>
                        <p><strong>Solutions:</strong></p>
                        <ul>
                            <li>Use the <button class="inline-btn" id="resyncBtn">Resync</button> button to reset synchronization</li>
                            <li>Start playback from slightly before the start and end of the sync point (timestamp)</li>
                            <li>Try restarting from the beginning</li>
                            <li>Avoid interacting with the original video for smooth timestamp control</li>
                        </ul>
                    </div>

                    <div class="compact-issue-box">
                        <h5>Playback speed issues</h5>
                        <p>Beta version may have issues with playback speed changes. Try using normal speed (1x) for best results.</p>
                    </div>
                </div>
        
                <div class="faq-section">
                    <h4>🎬 About YouTube Player</h4>
                    <p>We simply display the official YouTube player window as-is to ensure legal and ethical compliance. This means:</p>
                    <ul>
                        <li>Ads and recommended videos may appear (YouTube's standard behavior)</li>
                        <li>Original video is clickable but we recommend avoiding interaction for smooth timestamp control</li>
                        <li>All YouTube terms and copyright protections remain fully intact, ensuring no risk of disputes.</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- YouTube-style Layout -->
        <div class="youtube-layout">
            <!-- Main Content -->
            <div class="main-content">
                <!-- Video Player Section -->
                <div class="video-player-section">
                    <div class="video-container">
                        <div class="main-video-box">
                            <video id="reaction-player" controls style="display: none;"></video>
                            <div id="reaction-youtube-container" style="display: block;"></div>
                        </div>
                        
                        <div id="youtube-container" class="overlay-top-right">
                            <div id="youtube-player"></div>
                        </div>
                    </div>
                    
                    <!-- Quick Playback Controls - Right below video -->
                    <div class="quick-controls">
                        <button id="play-btn" class="btn btn-primary" disabled>Play</button>
                        <button id="pause-btn" class="btn btn-secondary" disabled>Pause</button>
                        <button id="stop-btn" class="btn btn-secondary" disabled style="display: none;">Stop</button>
                        <button id="restart-btn" class="btn btn-secondary" disabled>Restart</button>
                        <button id="help-btn" class="btn btn-info">Help</button>
                        <button id="resyncBtn" class="inline-btn">Resync</button>
                        <button id="overlay-settings-btn" class="btn btn-secondary" data-overlay-settings>⚙️</button>
                        
                        <!-- Overlay Settings Panel - Inside quick-controls -->
                        <div class="overlay-settings-panel" id="overlaySettingsPanel">
                            <div class="overlay-settings-header">
                                <h3 class="overlay-settings-title">
                                    <span>⚙️</span>
                                    <span>Overlay Settings</span>
                                    <button class="overlay-toggle-btn" id="overlayControlsToggleBtn" style="display: none;">▶</button>
                                </h3>
                            </div>
                            
                            <div class="compact-controls" id="overlayControls">
                                <div class="input-group">
                                    <label for="overlay-position" class="input-label">Position</label>
                                    <select id="overlay-position" class="input">
                                    <option value="top-right">Top Right</option>
                                    <option value="top-left">Top Left</option>
                                    <option value="bottom-right">Bottom Right</option>
                                    <option value="bottom-left">Bottom Left</option>
                                </select>
                            </div>
                                
                                <div class="input-group">
                                    <label for="overlay-size" class="input-label">Size</label>
                                <div class="slider-container">
                                        <input type="range" id="overlay-size" min="10" max="60" value="50">
                                    <span id="overlay-size-value" class="slider-value">50%</span>
                                </div>
                            </div>
                                
                                <div class="input-group">
                                    <label for="youtube-volume" class="input-label">Relative Volume</label>
                                <div class="slider-container">
                                    <input type="range" id="youtube-volume" min="0" max="100" value="100">
                                    <span id="youtube-volume-value" class="slider-value">100%</span>
                                </div>
                            </div>

                                             <div class="input-group">
                                 <label class="input-label">Visibility</label>
                                 <button id="toggle-overlay" class="btn btn-secondary" disabled>Hide Overlay</button>
                             </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- YouTube-style Video Info Section -->
                <div class="video-info-section" id="videoInfoSection">
                    <div class="video-title-section">
                        <h1 class="video-title-main" id="videoTitleMain">Synchronized Reaction Video</h1>
                        <div class="video-stats">
                            <span id="viewCount">0 views</span>
                            <span id="uploadDate">• Loading...</span>
                        </div>
                    </div>
                    
                    <div class="video-actions-section">
                        <div class="channel-info">
                            <div class="channel-avatar" id="channelAvatar">R</div>
                            <div class="channel-details">
                                <div class="channel-name" id="channelName">React Central</div>
                                <div class="subscriber-count" id="subscriberCount">0 subscribers</div>
                            </div>
                        </div>
                        
                        <div class="action-buttons">
                            <button class="action-btn subscribe-btn" id="subscribeBtn" onclick="toggleSubscription()">
                                <span class="material-icons">notifications</span>
                                <span>Subscribe</span>
                            </button>
                            <button class="action-btn" id="likeBtn" onclick="toggleLike()">
                                <span class="material-icons">thumb_up</span>
                                <span id="likeCount">0</span>
                            </button>
                            <button class="action-btn" id="bookmarkBtn" onclick="toggleBookmark()">
                                <span class="material-icons">bookmark</span>
                            </button>
                        </div>
                    </div>
                    
                    <div class="video-description">
                        <div class="description-text" id="videoDescription">
                            Watch synchronized reaction videos with original content. Load a VE URL to see the video details and interact with the content.
                        </div>
                    </div>
                    
                    <!-- Status Display -->
                    <div class="status" id="status">Status: Waiting</div>
                </div>
            </div>

            <!-- Sidebar -->
            <div class="sidebar">
                <!-- Sidebar Tabs -->
                <div class="sidebar-tabs">
                    <button class="sidebar-tab active" data-tab="latest">Latest</button>
                    <button class="sidebar-tab" data-tab="popular">Popular</button>
                </div>

                <!-- Tab Content -->
                <div class="sidebar-content">
                    <!-- Latest Videos Section -->
                    <div class="sidebar-section" id="latestSection">
                        <div id="latestVideos">
                            <!-- Latest videos will be loaded here -->
                        </div>
                    </div>

                    <!-- Popular Videos Section -->
                    <div class="sidebar-section" id="popularSection" style="display: none;">
                        <div id="popularVideos">
                            <!-- Popular videos will be loaded here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Beta Version Notice -->
        <div class="beta-notice">
            <div class="beta-notice-content">
                <span class="beta-notice-icon">⚠️</span>
                <div class="beta-notice-text desktop-beta-text">
                    <strong>Beta Version</strong><br>
                    Continuous playback is stable. Jumping to other points works but may occasionally cause unexpected issues.<br>
                    If you experience problems or want more information, please press the Help button.
                </div>
                <div class="beta-notice-text mobile-beta-text" style="display: none;">
                    <strong>Beta Version</strong><br>
                    Continuous playback is stable. Jumping to other points works but may occasionally cause unexpected issues.<br>
                    <strong>Note:</strong> iPhone/iOS support is not yet available.
                </div>
            </div>
        </div>

        <footer>
            <p>This application is designed to watch reaction videos without copyright infringement.</p>
        </footer>
    </div>

    <!-- YouTube API -->
    <script src="https://www.youtube.com/iframe_api"></script>
    <script>
    // Fixed Viewer JavaScript - Completely Redesigned Synchronization Logic with Enhanced Event Detection
    // Version 7: Fixed YouTube-YouTube mode synchronization and player creation with improved UI and default YouTube URL mode

    // Global variables
    let youtubePlayer = null;
    let reactionPlayer = null;
    let timestampData = null;
    let syncInterval = null; // Interval for file mode sync
    let isPlaying = false;
    let youtubeReady = false;
    let overlayPosition = 'top-right'; // Default overlay position
    let overlaySize = 50; // Default overlay size (%) - Changed from 20% to 50%
    let reactionSource = 'youtube'; // 'file' or 'youtube' - Changed default to 'youtube'
    let reactionYoutubePlayer = null;
    let isOverlayVisible = true; // Overlay visibility
    let youtubeVolume = 100; // YouTube volume (0-100)

    // Critical timestamp variables
    let youtubeStarted = false; // Flag to track if YouTube video has started
    let firstSyncPoint = null; // Store the first sync point
    let waitingForFirstSync = false; // Flag to indicate we're waiting for first sync point
    let youtubePlayerCreated = false; // Flag to track if YouTube player has been created
    let youtubeVideoId = null; // Store YouTube video ID for delayed creation
    let youtubeFirstPlayTime = null; // Store the time when YouTube video was first played
    let lastProcessedPauseTime = -1; // Track the last processed pause event time
    let lastProcessedPlayTime = -1; // Track the last processed play event time
    let youtubePaused = false; // Track if YouTube is paused by timestamp
    let lastSyncTime = 0; // Track the last time we synchronized videos
    let debugInfo = []; // Store debug information

    // New variables for improved synchronization
    let pauseEvents = []; // Store all pause events for quick lookup
    let playEvents = []; // Store all play events for quick lookup
    let currentSyncPoint = null; // Current active sync point
    let nextPauseTime = null; // Next pause time in reaction video timeline
    let nextPlayTime = null; // Next play time in reaction video timeline
    let syncMode = 'precise'; // 'precise' or 'relaxed' synchronization mode
    let missedEventCheckEnabled = true; // Enable checking for missed events
    let eventDetectionWindow = 0.8; // Increased event detection window (seconds) - Better for slower computers
    let lastReactionTime = 0; // Last processed reaction time (for file mode)

    // YouTube-YouTube synchronization variables
    let youtubeYoutubeMode = true; // Flag to indicate if both videos are YouTube - Changed default to true
    let reactionYoutubeReady = false; // Flag to track if reaction YouTube player is ready
    let reactionYoutubeCurrentTime = 0; // Current time of reaction YouTube player
    let lastReactionYoutubeTime = 0; // Last time of reaction YouTube player
    let youtubeYoutubeSyncInterval = null; // Interval for YouTube-YouTube synchronization
    let reactionYoutubeStateChangeTime = 0; // Time of last state change in reaction YouTube player
    let youtubeYoutubeSyncEnabled = true; // Enable YouTube-YouTube synchronization
    let youtubeYoutubeSyncFrequency = 300; // Frequency of YouTube-YouTube synchronization in ms (Increased for better performance)
    let youtubeYoutubeSyncThreshold = 0.5; // Threshold for YouTube-YouTube synchronization in seconds (Increased tolerance)
    let reactionYoutubeState = -1; // Current state of reaction YouTube player

    // YouTube API callback
    function onYouTubeIframeAPIReady() {
        youtubeReady = true;
        console.log("YouTube API is ready");
    }

    // DOM loaded event
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize status
        const statusElement = document.getElementById('status');
        if (statusElement) {
            statusElement.textContent = 'Status: Waiting';
        }
        
        // Prevent screen rotation on mobile
        if (window.innerWidth <= 768) {
            // Lock orientation to portrait
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('portrait').catch(function(error) {
                    console.log('Orientation lock failed:', error);
                });
            }
            
            // 회전 방지 코드 완전 제거 - 모바일에서 자연스러운 화면 표시
        }
        
        // 모바일 성능 최적화 함수
        function optimizeForMobile() {
            const isMobile = window.innerWidth <= 768;
            if (isMobile) {
                console.log('Mobile optimization applied');
                
                // 화면 크기에 따른 적응형 해상도 조절
                const screenWidth = window.innerWidth;
                let overlayQuality, mainQuality;
                
                if (screenWidth <= 480) {
                    // 매우 작은 화면 (아이폰 SE 등)
                    overlayQuality = 'small';  // 240p
                    mainQuality = 'medium';    // 360p
                } else if (screenWidth <= 768) {
                    // 일반 모바일 화면
                    overlayQuality = 'medium'; // 360p
                    mainQuality = 'large';     // 480p
                }
                
                // 오버레이 영상 해상도 강제 조절
                if (youtubePlayer && youtubePlayer.setPlaybackQuality) {
                    try {
                        youtubePlayer.setPlaybackQuality(overlayQuality);
                        console.log(`Overlay video quality set to ${overlayQuality}`);
                    } catch (error) {
                        console.log('Could not set overlay quality:', error);
                    }
                }
                
                // 메인 영상 해상도 조절
                if (reactionYoutubePlayer && reactionYoutubePlayer.setPlaybackQuality) {
                    try {
                        reactionYoutubePlayer.setPlaybackQuality(mainQuality);
                        console.log(`Main video quality set to ${mainQuality}`);
                    } catch (error) {
                        console.log('Could not set main video quality:', error);
                    }
                }
            }
        }
        
        // 화면 크기 변경 감지
        window.addEventListener('resize', function() {
            setTimeout(() => {
                if (typeof optimizeForMobile === 'function') {
                    optimizeForMobile();
                }
            }, 500); // 0.5초 후 실행
        });

        // Navigate to React Central
        function toggleSidebar() {
            window.location.href = '/react-central.html';
        }

        // Go back to React Central
        function goBack() {
            window.location.href = '/react-central.html';
        }
        // Overlay settings panel controls
        const overlayToggleBtn = document.getElementById('overlayToggleBtn');
        const overlayControlsToggleBtn = document.getElementById('overlayControlsToggleBtn');
        const overlaySettingsBtn = document.getElementById('overlay-settings-btn');
        const overlaySettingsPanel = document.getElementById('overlaySettingsPanel');
        const overlayControls = document.getElementById('overlayControls');
        
        // Desktop overlay toggle functionality
        if (overlayToggleBtn) {
            overlayToggleBtn.addEventListener('change', function() {
                const overlaySettingsPanel = document.getElementById('overlaySettingsPanel');
                if (this.checked) {
                    overlaySettingsPanel.classList.add('show');
                } else {
                    overlaySettingsPanel.classList.remove('show');
                }
            });
        }
        
        // Mobile overlay controls toggle functionality
        if (overlayControlsToggleBtn && overlayControls) {
            console.log('Setting up mobile toggle button');
            console.log('Button element:', overlayControlsToggleBtn);
            console.log('Controls element:', overlayControls);
            
            overlayControlsToggleBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                console.log('Toggle button clicked');
                console.log('Current display:', overlayControls.style.display);
                console.log('Window width:', window.innerWidth);
                
                if (window.innerWidth <= 768) {
                    const isHidden = overlayControls.style.display === 'none' || overlayControls.style.display === '';
                    overlayControls.style.display = isHidden ? 'grid' : 'none';
                    this.classList.toggle('collapsed');
                    this.textContent = isHidden ? '▼' : '▶';
                    console.log('New display:', overlayControls.style.display);
                    console.log('New text:', this.textContent);
                }
            });
            
                         // Also add touch event for mobile
             overlayControlsToggleBtn.addEventListener('touchstart', function(e) {
                 console.log('Touch event on toggle button');
             });
        }
        
        if (overlaySettingsBtn && overlaySettingsPanel) {
            overlaySettingsBtn.addEventListener('click', function() {
                overlaySettingsPanel.classList.toggle('show');
            });
        }
        
                         // Mobile: Set initial state for overlay controls
        if (window.innerWidth <= 768) {
            console.log('Setting mobile initial state');
            if (overlaySettingsPanel) {
                overlaySettingsPanel.classList.remove('show');
            }
            if (overlayControls) {
                overlayControls.style.display = 'none';
                console.log('Set overlayControls display to none');
            }
            if (overlayControlsToggleBtn) {
                overlayControlsToggleBtn.textContent = '▶';
                overlayControlsToggleBtn.classList.remove('collapsed');
                console.log('Set toggle button text to ▶');
            }
        }
        
        // Mobile: Controls are always visible between video and footer
        const quickControls = document.querySelector('.quick-controls');
        
        // Remove auto-hide functionality for mobile
        if (window.innerWidth <= 768) {
            if (quickControls) {
                quickControls.classList.remove('hidden');
            }
        }

        // Apple-style tooltip controls - Hover based
        const infoIcon = document.getElementById('infoIcon');
        const appleTooltip = document.getElementById('appleTooltip');
        
        if (infoIcon && appleTooltip) {
            // Show tooltip on hover
            infoIcon.addEventListener('mouseenter', function() {
                appleTooltip.classList.add('show');
            });
            
            // Hide tooltip when mouse leaves
            infoIcon.addEventListener('mouseleave', function() {
                appleTooltip.classList.remove('show');
            });
            
            // Also hide tooltip when mouse leaves the tooltip itself
            appleTooltip.addEventListener('mouseleave', function() {
                appleTooltip.classList.remove('show');
            });
        }
        // Check for VE URL in the URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const veId = urlParams.get('ve');
        
        if (veId) {
            console.log("VE URL detected:", veId);
            addDebugMessage(`VE URL detected: ${veId}`);
            
            // Load VE URL data from server
            loadVEUrlFromServer(veId);
        }
        
        // Element references
        const timestampFileInput = document.getElementById('timestamp-file');
        const reactionVideoInput = document.getElementById('reaction-video');
        const reactionUrlInput = document.getElementById('reaction-url');
        const youtubeUrlInput = document.getElementById('youtube-url');
        const loadBtn = document.getElementById('load-btn');
        const playBtn = document.getElementById('play-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const stopBtn = document.getElementById('stop-btn');
        const restartBtn = document.getElementById('restart-btn');
        const helpBtn = document.getElementById('help-btn');
        const helpFaq = document.getElementById('helpFaq');
        const helpCloseBtn = document.getElementById('helpCloseBtn');
        const resyncBtn = document.getElementById('resyncBtn');
        const messageElement = document.getElementById('message');
        const overlayPositionSelect = document.getElementById('overlay-position');
        const overlaySizeSlider = document.getElementById('overlay-size');
        const overlaySizeValue = document.getElementById('overlay-size-value');
        const sourceTypeRadios = document.querySelectorAll('input[name="reaction-source"]');
        const toggleOverlayBtn = document.getElementById('toggle-overlay');
        const youtubeVolumeSlider = document.getElementById('youtube-volume');
        const youtubeVolumeValue = document.getElementById('youtube-volume-value');
        
        reactionPlayer = document.getElementById('reaction-player');
        const reactionYoutubeContainer = document.getElementById('reaction-youtube-container');
        const youtubeContainer = document.getElementById('youtube-container');
        
        // Initially hide YouTube container until first sync point
        youtubeContainer.style.display = 'none';

        // Source type change event
        sourceTypeRadios.forEach(radio => {
            radio.addEventListener('change', function() {
                reactionSource = this.value;
                if (reactionSource === 'file') {
                    document.getElementById('file-source-container').style.display = 'block';
                    document.getElementById('youtube-source-container').style.display = 'none';
                    reactionPlayer.style.display = 'block';
                    reactionYoutubeContainer.style.display = 'none';
                    youtubeYoutubeMode = false;
                } else {
                    document.getElementById('file-source-container').style.display = 'none';
                    document.getElementById('youtube-source-container').style.display = 'block';
                    reactionPlayer.style.display = 'none';
                    reactionYoutubeContainer.style.display = 'block';
                    youtubeYoutubeMode = true;
                }
            });
        });

                    // Overlay position change event
            overlayPositionSelect.addEventListener('change', function() {
                overlayPosition = this.value;
                updateOverlayPosition();
            });

                    // Overlay size change event
            overlaySizeSlider.addEventListener('input', function() {
                overlaySize = parseInt(this.value);
                overlaySizeValue.textContent = overlaySize + '%';
                updateOverlaySize();
            });
        
        // Overlay toggle button event
        toggleOverlayBtn.addEventListener('click', function() {
            isOverlayVisible = !isOverlayVisible;
            updateOverlayVisibility();
            this.textContent = isOverlayVisible ? 'Hide Overlay' : 'Show Overlay';
        });
        
        // YouTube volume control event
        youtubeVolumeSlider.addEventListener('input', function() {
            youtubeVolume = parseInt(this.value);
            youtubeVolumeValue.textContent = youtubeVolume + '%';
            updateYoutubeVolume();
        });

        // Help button event
        if (helpBtn && helpFaq) {
            helpBtn.addEventListener('click', function() {
                // Show FAQ if hidden
                if (helpFaq.style.display === 'none') {
                    helpFaq.style.display = 'block';
                    
                    // Smooth scroll to FAQ
                    setTimeout(() => {
                        helpFaq.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'start',
                            inline: 'nearest'
                        });
                    }, 100);
                } else {
                    helpFaq.style.display = 'none';
                }
            });
        }

        // Help close button event
        if (helpCloseBtn && helpFaq) {
            helpCloseBtn.addEventListener('click', function() {
                helpFaq.style.display = 'none';
                
                // Scroll back to top smoothly
                window.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            });
        }

        // Inline resync button event
        if (resyncBtn) {
            resyncBtn.addEventListener('click', function() {
                resyncVideos();
            });
        }

        // Reaction player setup (HTML5 video)
        reactionPlayer.addEventListener('loadedmetadata', function() {
            console.log('Status: Reaction Video Loaded');
        });
        
        // Reaction video ended event (HTML5 video)
        reactionPlayer.addEventListener('ended', function() {
            stopSynchronizedPlayback();
        });
        
        // Reaction video timeupdate event (HTML5 video) - ONLY for file mode sync
        reactionPlayer.addEventListener('timeupdate', function() {
            // Only run this logic if in file mode
            if (!youtubeYoutubeMode) {
                const currentTime = reactionPlayer.currentTime;
                handleSynchronization(currentTime);
            }
        });

        // Timestamp file load
        if (timestampFileInput) {
            timestampFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    timestampData = JSON.parse(e.target.result);
                    
                    // ENHANCED: Pre-process all events for quick lookup
                    if (timestampData.sync_points && timestampData.sync_points.length > 0) {
                        // Clear existing events
                        pauseEvents = [];
                        playEvents = [];
                        debugInfo = [];
                        
                        // Process all events
                        timestampData.sync_points.forEach(point => {
                            // Store first play time
                            if (point.youtube_first_play_time !== undefined && point.youtube_first_play_time !== null) {
                                youtubeFirstPlayTime = point.youtube_first_play_time;
                            }
                            
                            // Categorize events
                            if (point.event === 'youtube_pause') {
                                pauseEvents.push(point);
                            } else if (point.event === 'youtube_play') {
                                playEvents.push(point);
                            }
                        });
                        
                        // Sort events by reaction_time
                        pauseEvents.sort((a, b) => a.reaction_time - b.reaction_time);
                        playEvents.sort((a, b) => a.reaction_time - b.reaction_time);
                        
                        // Find first sync point (first play event)
                        firstSyncPoint = playEvents.length > 0 ? playEvents[0] : null;
                        
                        if (firstSyncPoint) {
                            console.log("First sync point loaded:", firstSyncPoint);
                            console.log("All pause events:", pauseEvents);
                            console.log("All play events:", playEvents);
                            
                            addDebugMessage("Timestamp file loaded successfully");
                            addDebugMessage(`Found ${playEvents.length} play events and ${pauseEvents.length} pause events`);
                            
                            // Log all events for debugging
                            playEvents.forEach(event => {
                                addDebugMessage(`Play event at ${event.reaction_time.toFixed(2)}s -> YouTube ${event.relative_youtube_time.toFixed(2)}s`);
                            });
                            
                            pauseEvents.forEach(event => {
                                addDebugMessage(`Pause event at ${event.reaction_time.toFixed(2)}s -> YouTube ${event.relative_youtube_time.toFixed(2)}s`);
                            });
                        }
                    }
                    
                    showMessage('Timestamp file loaded successfully.', 'success');
                    console.log('Status: Timestamp Loaded');
                    updateDebugDisplay();
                } catch (error) {
                    showMessage('Timestamp file parsing error: ' + error.message, 'error');
                }
            };
            reader.onerror = function() {
                showMessage('Error reading file.', 'error');
            };
            reader.readAsText(file);
            });
        }

        // Reaction video load (file)
        if (reactionVideoInput) {
            reactionVideoInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const url = URL.createObjectURL(file);
            reactionPlayer.src = url;
            showMessage('Reaction video loaded.', 'success');
            });
        }

        // Load button click
        if (loadBtn) {
            loadBtn.addEventListener('click', function() {
            // Check if we're in VE server mode
            const urlParams = new URLSearchParams(window.location.search);
            const veId = urlParams.get('ve');
            
            if (veId) {
                // In VE server mode, load button should just re-trigger auto-load
                console.log("🔄 Re-triggering auto-load in VE server mode");
                addDebugMessage("🔄 Re-triggering auto-load in VE server mode");
                autoLoadForVEServer();
                return;
            }
            
            // Normal load logic for manual mode
            const youtubeUrl = youtubeUrlInput.value.trim();
            
            if (!timestampData) {
                showMessage('Please load timestamp file first.', 'error');
                return;
            }
            
            if (reactionSource === 'file' && !reactionPlayer.src) {
                showMessage('Please select reaction video first.', 'error');
                return;
            }
            
            if (reactionSource === 'youtube') {
                const reactionUrl = reactionUrlInput.value.trim();
                if (!reactionUrl) {
                    showMessage('Please enter reaction video URL.', 'error');
                    return;
                }
                
                // Extract reaction video YouTube ID
                const reactionVideoId = extractYouTubeVideoId(reactionUrl);
                if (!reactionVideoId) {
                    showMessage('Invalid reaction video YouTube URL.', 'error');
                    return;
                }
                
                // Remove existing reaction YouTube player
                if (reactionYoutubePlayer) {
                    reactionYoutubePlayer.destroy();
                    reactionYoutubePlayer = null;
                }
                
                // Set YouTube-YouTube mode flag
                youtubeYoutubeMode = true;
                reactionYoutubeReady = false;
                
                // Create new reaction YouTube player with improved height
                // 모바일 감지 및 해상도 최적화
                const isMobile = window.innerWidth <= 768;
                const playerVars = isMobile ? {
                    'playsinline': 1,
                    'controls': 1,
                    'autoplay': 0,
                    'rel': 0,
                    'vq': 'large',  // 메인 영상은 높은 해상도 (480p) - 좋은 화질
                    'iv_load_policy': 3,  // 주석 비활성화
                    'cc_load_policy': 0   // 자막 비활성화
                } : {
                    'playsinline': 1,
                    'controls': 1,
                    'autoplay': 0,
                    'rel': 0,
                    'vq': 'medium' // 데스크탑 메인 영상은 중간 해상도 (360p) - 적절한 화질
                };
                
                reactionYoutubePlayer = new YT.Player('reaction-youtube-container', {
                    height: '540', // 1.5배 높이 증가 (기본 360px의 1.5배)
                    width: '100%',
                    videoId: reactionVideoId,
                    playerVars: playerVars,
                    events: {
                        'onReady': onReactionPlayerReady,
                        'onStateChange': onReactionPlayerStateChange
                    }
                });
                
                addDebugMessage(`Created reaction YouTube player with video ID: ${reactionVideoId}`);
            } else {
                // Set YouTube-YouTube mode flag to false for file mode
                youtubeYoutubeMode = false;
            }
            
            if (!youtubeUrl) {
                showMessage('Please enter YouTube URL.', 'error');
                return;
            }

            // Extract YouTube video ID
            youtubeVideoId = extractYouTubeVideoId(youtubeUrl);
            if (!youtubeVideoId) {
                showMessage('Invalid YouTube URL.', 'error');
                return;
            }

            // CRITICAL CHANGE: We don't create the YouTube player here anymore
            // We'll create it only when we reach the first sync point
            
            // If there was a previous player, destroy it
            if (youtubePlayer) {
                youtubePlayer.destroy();
                youtubePlayer = null;
                youtubePlayerCreated = false;
            }
            
            // YouTube container will be shown when first sync point is reached
            // (Don't hide it here to avoid timing issues)

            console.log('Status: Ready to Play');
            enableControls(true);
            
            // Reset YouTube started flag
            youtubeStarted = false;
            waitingForFirstSync = false;
            
            // Reset tracking variables
            lastProcessedPauseTime = -1;
            lastProcessedPlayTime = -1;
            youtubePaused = false;
            currentSyncPoint = null;
            nextPauseTime = null;
            nextPlayTime = null;
            lastReactionTime = 0;
            reactionYoutubeCurrentTime = 0;
            lastReactionYoutubeTime = 0;
            
            // Clear debug info
            debugInfo = [];
            addDebugMessage("Ready to play. Click Play to start.");
            updateDebugDisplay();
            
            });
        }

        // Play button click
        if (playBtn) {
            playBtn.addEventListener('click', function() {
            // Check if we're in VE server mode
            const urlParams = new URLSearchParams(window.location.search);
            const veId = urlParams.get('ve');
            
            if (veId) {
                // In VE server mode, check if data is loaded
                if (!youtubeVideoId) {
                    showMessage('Please load videos first.', 'error');
                    return;
                }
                
                if (reactionSource === 'file' && !reactionPlayer.src) {
                    showMessage('Please select reaction video first.', 'error');
                    return;
                }
                
                if (reactionSource === 'youtube' && !reactionYoutubePlayer) {
                    showMessage('Please load reaction video URL first.', 'error');
                    return;
                }
            } else {
                // Normal mode checks
                if (!youtubeVideoId) {
                    showMessage('Please load videos first.', 'error');
                    return;
                }
                
                if (reactionSource === 'file' && !reactionPlayer.src) {
                    showMessage('Please select reaction video first.', 'error');
                    return;
                }
                
                if (reactionSource === 'youtube' && !reactionYoutubePlayer) {
                    showMessage('Please load reaction video URL first.', 'error');
                    return;
                }
            }
            
            startSynchronizedPlayback();
            });
        }

        // Pause button click
        if (pauseBtn) {
            pauseBtn.addEventListener('click', function() {
                pauseSynchronizedPlayback();
            });
        }

        // Stop button click
        if (stopBtn) {
            stopBtn.addEventListener('click', function() {
                stopSynchronizedPlayback();
            });
        }

        // Restart button click
        if (restartBtn) {
            restartBtn.addEventListener('click', function() {
                restartSynchronizedPlayback();
            });
        }

        // Resync function for inline button
        function resyncVideos() {
            console.log("🔄 Resync: Resetting synchronization");
            addDebugMessage("🔄 Resync: Resetting synchronization");
            
            // Reset sync state
            youtubeStarted = false;
            waitingForFirstSync = false;
            currentSyncPoint = null;
            nextPauseTime = null;
            nextPlayTime = null;
            lastProcessedPauseTime = -1;
            lastProcessedPlayTime = -1;
            
            // If currently playing, restart playback
            if (isPlaying) {
                pauseSynchronizedPlayback();
                setTimeout(() => {
                    startSynchronizedPlayback();
                    showMessage('Resync completed!', 'success');
                }, 100);
            } else {
                // If not playing, just reset the state
                showMessage('Synchronization reset! Start playback to continue.', 'success');
            }
        }
        
        // Initial overlay size display and slider value
        overlaySizeSlider.value = overlaySize; // Set slider to 50
        overlaySizeValue.textContent = overlaySize + '%'; // Display 50%
        
        // Initial YouTube volume display
        youtubeVolumeValue.textContent = youtubeVolume + '%';
        
        // Add debug message for initial state
        addDebugMessage("Initialized with YouTube URL mode as default");
    });

    // Central synchronization logic (called by timeupdate or interval)
    function handleSynchronization(currentTime) {
        // Update debug info
        updateDebugInfo(currentTime);

        // First sync point handling
        if (isPlaying && waitingForFirstSync && firstSyncPoint) {
            // Check if we've reached the first sync point
            if (currentTime >= firstSyncPoint.reaction_time) {
                console.log("First sync point reached at reaction time:", currentTime);
                addDebugMessage(`First sync point reached at ${currentTime.toFixed(2)}s`);
                
                // Use exact relative_youtube_time for YouTube start
                let youtubeStartTime = 0;
                if (firstSyncPoint.relative_youtube_time !== null && firstSyncPoint.relative_youtube_time !== undefined) {
                    youtubeStartTime = firstSyncPoint.relative_youtube_time;
                    console.log("Using relative YouTube time:", youtubeStartTime);
                    addDebugMessage(`Using relative YouTube time: ${youtubeStartTime.toFixed(2)}s`);
                } else if (firstSyncPoint.youtube_time !== null) {
                    youtubeStartTime = firstSyncPoint.youtube_time;
                    console.log("Using original YouTube time:", youtubeStartTime);
                    addDebugMessage(`Using original YouTube time: ${youtubeStartTime.toFixed(2)}s`);
                }
                
                // Create YouTube player only when we reach the first sync point
                if (!youtubePlayerCreated && youtubeVideoId) {
                    createYouTubePlayer(youtubeVideoId, youtubeStartTime);
                } else if (youtubePlayer) {
                    youtubePlayer.seekTo(youtubeStartTime, true);
                    youtubePlayer.playVideo();
                    document.getElementById('youtube-container').style.display = 'block';
                }
                
                youtubeStarted = true;
                waitingForFirstSync = false;
                currentSyncPoint = firstSyncPoint;
                
                // Update next pause/play times
                updateNextEventTimes(currentTime);
                
                // Update status
                document.getElementById('status').textContent = 'Status: Playing (YouTube started)';
            }
            return; // Don't process other events until first sync is done
        }
        
        // Check for missed events first
        if (isPlaying && youtubeStarted && missedEventCheckEnabled) {
            checkForMissedEvents(currentTime);
        }
        
        // Precise event detection with wider window
        if (isPlaying && youtubeStarted) {
            // Check for pause events with enhanced timing
            if (nextPauseTime !== null && currentTime >= nextPauseTime) {
                // Find the exact pause event with wider detection window
                const pauseEvent = findNearestEvent(pauseEvents, currentTime, eventDetectionWindow);
                
                if (pauseEvent && pauseEvent.reaction_time > lastProcessedPauseTime) {
                    console.log("Pause event detected at reaction time:", currentTime, "event time:", pauseEvent.reaction_time);
                    addDebugMessage(`Pause event detected at ${currentTime.toFixed(2)}s (event: ${pauseEvent.reaction_time.toFixed(2)}s)`);
                    
                    // Update last processed pause time
                    lastProcessedPauseTime = pauseEvent.reaction_time;
                    
                    // Use the exact relative_youtube_time from the pause event
                    if (youtubePlayer && !youtubePaused) {
                        youtubePaused = true;
                        
                        console.log("Pausing YouTube at exact time:", pauseEvent.relative_youtube_time);
                        addDebugMessage(`Pausing YouTube at ${pauseEvent.relative_youtube_time.toFixed(2)}s`);
                        
                        youtubePlayer.pauseVideo();
                        
                        document.getElementById('status').textContent = 'Status: YouTube Paused (by timestamp)';
                    }
                    
                    // Update next event times
                    updateNextEventTimes(currentTime);
                }
            }
            
            // Check for play events with enhanced timing
            if (nextPlayTime !== null && currentTime >= nextPlayTime) {
                // Find the exact play event with wider detection window
                const playEvent = findNearestEvent(playEvents, currentTime, eventDetectionWindow);
                
                if (playEvent && playEvent.reaction_time > lastProcessedPlayTime) {
                    console.log("Play event detected at reaction time:", currentTime, "event time:", playEvent.reaction_time);
                    addDebugMessage(`Play event detected at ${currentTime.toFixed(2)}s (event: ${playEvent.reaction_time.toFixed(2)}s)`);
                    
                    // Update last processed play time
                    lastProcessedPlayTime = playEvent.reaction_time;
                    
                    // Use the exact relative_youtube_time from the play event
                    if (youtubePlayer) {
                        youtubePaused = false;
                        
                        console.log("Resuming YouTube at exact time:", playEvent.relative_youtube_time);
                        addDebugMessage(`Resuming YouTube at ${playEvent.relative_youtube_time.toFixed(2)}s`);
                        
                        youtubePlayer.seekTo(playEvent.relative_youtube_time, true);
                        youtubePlayer.playVideo();
                        
                        currentSyncPoint = playEvent;
                        
                        document.getElementById('status').textContent = 'Status: Playing (synchronized)';
                    }
                    
                    // Update next event times
                    updateNextEventTimes(currentTime);
                }
            }
            
            // Only perform regular synchronization if not paused and in precise mode
            if (!youtubePaused && syncMode === 'precise') {
                synchronizeYouTubePosition(currentTime);
            }
            
            // Update last reaction time (only for file mode)
            if (!youtubeYoutubeMode) {
                lastReactionTime = currentTime;
            }
        }
    }

    // ENHANCED: Find nearest event with wider detection window
    function findNearestEvent(events, currentTime, maxDiff) {
        if (!events || events.length === 0) return null;
        
        let nearestEvent = null;
        let minDiff = maxDiff;
        
        for (const event of events) {
            const diff = Math.abs(event.reaction_time - currentTime);
            if (diff < minDiff) {
                minDiff = diff;
                nearestEvent = event;
            }
        }
        
        return nearestEvent;
    }

    // ENHANCED: Check for missed events
    function checkForMissedEvents(currentTime) {
        // Check for missed play events
        for (const event of playEvents) {
            if (event.reaction_time > lastProcessedPlayTime && 
                event.reaction_time < currentTime && 
                Math.abs(event.reaction_time - currentTime) < 3.0) { // Increased range for slower computers
                
                console.log("Catching up missed play event at:", event.reaction_time);
                addDebugMessage(`Catching up missed play event at ${event.reaction_time.toFixed(2)}s`);
                
                // Process the missed play event
                if (youtubePlayer && youtubePaused) {
                    youtubePaused = false;
                    
                    // Special handling for specific events
                    if (Math.abs(event.reaction_time - 43.858) < 0.1) {
                        console.log("Special handling for 43.858s play event");
                        addDebugMessage("Special handling for 43.858s play event");
                    }
                    
                    if (Math.abs(event.reaction_time - 70.681) < 0.1) {
                        console.log("Special handling for 70.681s play event");
                        addDebugMessage("Special handling for 70.681s play event");
                    }
                    
                    // Seek to exact position and play
                    youtubePlayer.seekTo(event.relative_youtube_time, true);
                    youtubePlayer.playVideo();
                    
                    // Update current sync point
                    currentSyncPoint = event;
                    
                    // Update status
                    document.getElementById('status').textContent = 'Status: Playing (synchronized after catch-up)';
                }
                
                // Update last processed play time
                lastProcessedPlayTime = event.reaction_time;
            }
        }
        
        // Check for missed pause events
        for (const event of pauseEvents) {
            if (event.reaction_time > lastProcessedPauseTime && 
                event.reaction_time < currentTime && 
                Math.abs(event.reaction_time - currentTime) < 3.0) { // Increased range for slower computers
                
                console.log("Catching up missed pause event at:", event.reaction_time);
                addDebugMessage(`Catching up missed pause event at ${event.reaction_time.toFixed(2)}s`);
                
                // Process the missed pause event
                if (youtubePlayer && !youtubePaused) {
                    youtubePaused = true;
                    
                    // Pause YouTube video
                    youtubePlayer.pauseVideo();
                    
                    // Update status
                    document.getElementById('status').textContent = 'Status: YouTube Paused (by timestamp catch-up)';
                }
                
                // Update last processed pause time
                lastProcessedPauseTime = event.reaction_time;
            }
        }
        
        // Update next event times
        updateNextEventTimes(currentTime);
    }

    // Create YouTube player with delayed initialization
    function createYouTubePlayer(videoId, startTime) {
        console.log("Creating YouTube player with video ID:", videoId, "starting at time:", startTime);
        addDebugMessage(`Creating YouTube player with video ID: ${videoId}, starting at time: ${startTime.toFixed(2)}s`);
        
        // Ensure startTime is a valid number
        if (startTime === null || startTime === undefined || isNaN(startTime) || startTime < 0) {
            console.log("Invalid startTime, defaulting to 0");
            addDebugMessage("Invalid startTime, defaulting to 0");
            startTime = 0;
        }
        
        // Create new YouTube player
        youtubePlayer = new YT.Player('youtube-player', {
            height: 'auto',        /* 16:9 비율 보장을 위해 auto로 변경 */
            width: '100%',
            videoId: videoId,
            playerVars: {
                'playsinline': 1,
                'controls': 0, // Disable controls for better overlay experience
                'autoplay': 0, // Critical: No autoplay
                'start': Math.floor(startTime), // Set start time
                'rel': 0,
                'vq': 'medium' // 오버레이 영상은 중간 해상도 (360p) - 적절한 화질
            },
            events: {
                'onReady': function(event) {
                    console.log("YouTube player ready, setting volume and playing at time:", startTime);
                    addDebugMessage(`YouTube player ready, playing at time: ${startTime.toFixed(2)}s`);
                    
                    // Set volume
                    event.target.setVolume(youtubeVolume);
                    // Seek to exact time (more precise than 'start' parameter)
                    event.target.seekTo(startTime, true);
                    // Play video
                    event.target.playVideo();
                    
                    // Show the YouTube container
                    document.getElementById('youtube-container').style.display = 'block';
                    
                    // Apply overlay settings
                    updateOverlayPosition();
                    updateOverlaySize();
                    updateOverlayVisibility();
                },
                'onStateChange': onPlayerStateChange
            }
        });
        
        youtubePlayerCreated = true;
    }

    // Reaction YouTube player ready callback
    function onReactionPlayerReady(event) {
        document.getElementById('status').textContent = 'Status: Reaction Video Loaded';
        reactionYoutubeReady = true;
        addDebugMessage("Reaction YouTube player ready");
        
        // 모바일 최적화 적용
        setTimeout(() => {
            if (typeof optimizeForMobile === 'function') {
                optimizeForMobile();
            }
        }, 1000); // 1초 후 실행
        
        // If playback was started before player was ready, start sync now
        if (youtubeYoutubeMode && isPlaying) {
            startYoutubeYoutubeSync();
        }
        
        // Try auto-start playback if all conditions are met
        setTimeout(() => {
            autoStartPlayback();
        }, 500);
    }

    // Reaction YouTube player state change callback
    function onReactionPlayerStateChange(event) {
        // Store the current state
        reactionYoutubeState = event.data;
        reactionYoutubeStateChangeTime = Date.now();
        
        // Handle reaction player state changes
        if (youtubeYoutubeMode && isPlaying) {
            if (event.data === YT.PlayerState.PLAYING) {
                addDebugMessage("Reaction YouTube player started playing");
                // Synchronization is handled by the interval
            } else if (event.data === YT.PlayerState.PAUSED) {
                addDebugMessage("Reaction YouTube player paused");
                // If original YouTube player exists and is playing, pause it
                if (youtubePlayer && youtubePlayerCreated && youtubePlayer.getPlayerState() === YT.PlayerState.PLAYING) {
                    youtubePlayer.pauseVideo();
                    addDebugMessage("Paused original YouTube player due to reaction pause");
                }
            } else if (event.data === YT.PlayerState.ENDED) {
                addDebugMessage("Reaction YouTube player ended");
                stopSynchronizedPlayback();
            }
        }
    }

    // YouTube player state change callback
    function onPlayerStateChange(event) {
        // Handle YouTube player state changes
        if (event.data === YT.PlayerState.PLAYING) {
            addDebugMessage("Original YouTube player started playing");
        } else if (event.data === YT.PlayerState.PAUSED) {
            addDebugMessage("Original YouTube player paused");
        } else if (event.data === YT.PlayerState.ENDED) {
            addDebugMessage("Original YouTube player ended");
        } else if (event.data === YT.PlayerState.BUFFERING) {
            addDebugMessage("Original YouTube player buffering");
        }
    }

    // Find sync point for a given reaction time
    function findSyncPointForTime(reactionTime) {
        // Find the nearest sync point before the given reaction time
        let nearestPoint = null;
        let minDiff = Infinity;
        
        for (const point of playEvents) {
            if (point.reaction_time <= reactionTime) {
                const diff = reactionTime - point.reaction_time;
                if (diff < minDiff) {
                    minDiff = diff;
                    nearestPoint = point;
                }
            }
        }
        
        return nearestPoint;
    }

    // Start YouTube-YouTube synchronization interval
    function startYoutubeYoutubeSync() {
        if (youtubeYoutubeSyncInterval) {
            clearInterval(youtubeYoutubeSyncInterval);
        }
        
        youtubeYoutubeSyncInterval = setInterval(function() {
            if (!youtubeYoutubeMode || !isPlaying || !reactionYoutubeReady) return;
            
            // Get current time of reaction video
            try {
                reactionYoutubeCurrentTime = reactionYoutubePlayer.getCurrentTime();
                
                // Call the central synchronization logic
                handleSynchronization(reactionYoutubeCurrentTime);
                
                // Update last reaction YouTube time
                lastReactionYoutubeTime = reactionYoutubeCurrentTime;
            } catch (error) {
                console.error("Error in YouTube-YouTube sync interval:", error);
                addDebugMessage(`ERROR in YouTube-YouTube sync: ${error.message}`);
            }
        }, youtubeYoutubeSyncFrequency);
        
        addDebugMessage("Started YouTube-YouTube synchronization interval");
    }

    // ENHANCED: Update next event times based on current position
    function updateNextEventTimes(currentTime) {
        // Find next pause event
        nextPauseTime = null;
        for (const event of pauseEvents) {
            if (event.reaction_time > currentTime) {
                nextPauseTime = event.reaction_time;
                console.log("Next pause at reaction time:", nextPauseTime, "YouTube time:", event.relative_youtube_time);
                addDebugMessage(`Next pause at ${nextPauseTime.toFixed(2)}s -> YouTube ${event.relative_youtube_time.toFixed(2)}s`);
                break;
            }
        }
        
        // Find next play event
        nextPlayTime = null;
        for (const event of playEvents) {
            if (event.reaction_time > currentTime) {
                nextPlayTime = event.reaction_time;
                console.log("Next play at reaction time:", nextPlayTime, "YouTube time:", event.relative_youtube_time);
                addDebugMessage(`Next play at ${nextPlayTime.toFixed(2)}s -> YouTube ${event.relative_youtube_time.toFixed(2)}s`);
                break;
            }
        }
        
        // Update debug display
        updateDebugDisplay();
    }



    // ENHANCED: Synchronize YouTube position based on current time
    function synchronizeYouTubePosition(currentTime) {
        if (!youtubePlayer || !currentSyncPoint || !youtubeStarted) return;
        
        // Check if YouTube player is fully ready
        if (!youtubePlayer.getCurrentTime || typeof youtubePlayer.getCurrentTime !== 'function') {
            return; // Player not ready yet, skip this sync cycle
        }
        
        try {
            // Calculate expected YouTube time based on current sync point
            const timeSinceSyncPoint = currentTime - currentSyncPoint.reaction_time;
            let expectedYoutubeTime = currentSyncPoint.relative_youtube_time + timeSinceSyncPoint;
            
            // Get current YouTube time
            const currentYoutubeTime = youtubePlayer.getCurrentTime();
            
            // Only sync if difference is significant
            if (Math.abs(currentYoutubeTime - expectedYoutubeTime) > youtubeYoutubeSyncThreshold) {
                console.log("Syncing YouTube time from", currentYoutubeTime, "to", expectedYoutubeTime);
                addDebugMessage(`Syncing YouTube time from ${currentYoutubeTime.toFixed(2)}s to ${expectedYoutubeTime.toFixed(2)}s`);
                youtubePlayer.seekTo(expectedYoutubeTime, true);
            }
        } catch (error) {
            console.error("Error in YouTube synchronization:", error);
            // Don't add debug message for every error to avoid spam
        }
    }

    // Start synchronized playback
    function startSynchronizedPlayback() {
        if (isPlaying) return;
        
        // Get current reaction time
        let currentReactionTime = 0;
        if (reactionSource === 'file') {
            currentReactionTime = reactionPlayer.currentTime;
        } else {
            if (reactionYoutubeReady && reactionYoutubePlayer && reactionYoutubePlayer.getCurrentTime) {
                try {
                    currentReactionTime = reactionYoutubePlayer.getCurrentTime();
                } catch (error) {
                    console.error("Error getting reaction YouTube time:", error);
                    currentReactionTime = 0;
                }
            }
        }
        
        // Clear debug info
        debugInfo = [];
        addDebugMessage(`Starting playback at reaction time: ${currentReactionTime.toFixed(2)}s`);
        
        isPlaying = true;
        
        // ENHANCED: Check if we're starting from the beginning or before the first sync point
        if (firstSyncPoint && currentReactionTime < firstSyncPoint.reaction_time) {
            console.log("Starting from beginning or before first sync point");
            addDebugMessage("Starting from beginning or before first sync point");
            waitingForFirstSync = true;
            document.getElementById('status').textContent = 'Status: Playing (waiting for sync point)';
        } else {
            // We're already past the first sync point, find the nearest sync point
            console.log("Starting from middle, finding nearest sync point");
            addDebugMessage("Starting from middle, finding nearest sync point");
            waitingForFirstSync = false;
            
            let nearestPoint = findSyncPointForTime(currentReactionTime);
            if (nearestPoint) {
                currentSyncPoint = nearestPoint;
                // Calculate expected YouTube time
                const timeSinceSyncPoint = currentReactionTime - nearestPoint.reaction_time;
                const expectedYoutubeTime = nearestPoint.relative_youtube_time + timeSinceSyncPoint;
                
                console.log("Using sync point:", nearestPoint);
                console.log("Expected YouTube time:", expectedYoutubeTime);
                addDebugMessage(`Using sync point at ${nearestPoint.reaction_time.toFixed(2)}s`);
                addDebugMessage(`Expected YouTube time: ${expectedYoutubeTime.toFixed(2)}s`);
                
                // Create or update YouTube player
                if (!youtubePlayerCreated) {
                    createYouTubePlayer(youtubeVideoId, expectedYoutubeTime);
                } else if (youtubePlayer) {
                    youtubePlayer.seekTo(expectedYoutubeTime, true);
                    youtubePlayer.playVideo();
                    document.getElementById('youtube-container').style.display = 'block';
                }
                youtubeStarted = true;
                updateNextEventTimes(currentReactionTime);
                document.getElementById('status').textContent = 'Status: Playing (synchronized)';
            } else {
                addDebugMessage("ERROR: Could not find a sync point. Please restart.");
                updateDebugDisplay();
                isPlaying = false;
                return;
            }
        }
        
        // Play reaction video
        if (reactionSource === 'file') {
            reactionPlayer.play();
            // Start sync interval for file mode
            if (syncInterval) clearInterval(syncInterval);
            syncInterval = setInterval(() => {
                if (isPlaying && !youtubeYoutubeMode) {
                    handleSynchronization(reactionPlayer.currentTime);
                }
            }, 300); // File mode sync frequency (Increased for better performance)
        } else {
            if (reactionYoutubeReady) {
                reactionYoutubePlayer.playVideo();
                addDebugMessage("Started reaction YouTube player");
                // Start YouTube-YouTube synchronization interval
                startYoutubeYoutubeSync();
            } else {
                addDebugMessage("Waiting for reaction YouTube player to be ready...");
                // Sync will start in onReactionPlayerReady
            }
        }
        
        // Don't reset YouTube pause state - keep the current pause state
        // youtubePaused should remain as is (true if paused by timestamp, false if playing)
        lastProcessedPauseTime = -1;
        lastProcessedPlayTime = -1;
        lastReactionTime = currentReactionTime;
        
        updateButtonStates(true);
        updateDebugDisplay();
    }

    // Pause synchronized playback
    function pauseSynchronizedPlayback() {
        if (!isPlaying) return;
        isPlaying = false;
        
        // Pause reaction video
        if (reactionSource === 'file') {
            reactionPlayer.pause();
        } else {
            if (reactionYoutubeReady) {
                reactionYoutubePlayer.pauseVideo();
                addDebugMessage("Paused reaction YouTube player");
            }
        }
        
        // Pause YouTube video if it has started
        if (youtubeStarted && youtubePlayer) {
            youtubePlayer.pauseVideo();
            addDebugMessage("Paused original YouTube player");
        }
        
        // Stop sync intervals
        if (syncInterval) {
            clearInterval(syncInterval);
            syncInterval = null;
        }
        if (youtubeYoutubeSyncInterval) {
            clearInterval(youtubeYoutubeSyncInterval);
            youtubeYoutubeSyncInterval = null;
            addDebugMessage("Stopped YouTube-YouTube synchronization interval");
        }
        
        document.getElementById('status').textContent = 'Status: Paused';
        addDebugMessage("Playback paused");
        updateDebugDisplay();
        updateButtonStates(false);
    }

    // Stop synchronized playback
    function stopSynchronizedPlayback() {
        isPlaying = false;
        waitingForFirstSync = false;
        
        // Stop and rewind reaction video
        if (reactionSource === 'file') {
            reactionPlayer.pause();
            reactionPlayer.currentTime = 0;
        } else {
            if (reactionYoutubeReady) {
                reactionYoutubePlayer.pauseVideo();
                reactionYoutubePlayer.seekTo(0, true);
                addDebugMessage("Stopped and rewound reaction YouTube player");
            }
        }
        
        // Stop YouTube video if it exists
        if (youtubePlayer) {
            youtubePlayer.pauseVideo();
            youtubePlayer.seekTo(0, true);
            
            // Hide YouTube container
            document.getElementById('youtube-container').style.display = 'none';
            addDebugMessage("Stopped and rewound original YouTube player");
        }
        
        // Stop sync intervals
        if (syncInterval) {
            clearInterval(syncInterval);
            syncInterval = null;
        }
        if (youtubeYoutubeSyncInterval) {
            clearInterval(youtubeYoutubeSyncInterval);
            youtubeYoutubeSyncInterval = null;
            addDebugMessage("Stopped YouTube-YouTube synchronization interval");
        }
        
        document.getElementById('status').textContent = 'Status: Stopped';
        addDebugMessage("Playback stopped");
        updateDebugDisplay();
        updateButtonStates(false);
        
        // Reset YouTube started flag
        youtubeStarted = false;
        youtubePaused = false;
        currentSyncPoint = null;
        nextPauseTime = null;
        nextPlayTime = null;
        lastProcessedPauseTime = -1;
        lastProcessedPlayTime = -1;
        lastReactionTime = 0;
        reactionYoutubeCurrentTime = 0;
        lastReactionYoutubeTime = 0;
    }

    // Restart synchronized playback
    function restartSynchronizedPlayback() {
        // Rewind reaction video
        if (reactionSource === 'file') {
            reactionPlayer.currentTime = 0;
        } else {
            if (reactionYoutubeReady) {
                reactionYoutubePlayer.seekTo(0, true);
                addDebugMessage("Rewound reaction YouTube player");
            }
        }
        
        // Reset YouTube started flag
        youtubeStarted = false;
        waitingForFirstSync = false;
        
        // Hide YouTube container
        document.getElementById('youtube-container').style.display = 'none';
        
        // Reset YouTube pause state
        youtubePaused = false;
        currentSyncPoint = null;
        nextPauseTime = null;
        nextPlayTime = null;
        lastProcessedPauseTime = -1;
        lastProcessedPlayTime = -1;
        lastReactionTime = 0;
        reactionYoutubeCurrentTime = 0;
        lastReactionYoutubeTime = 0;
        
        // Clear debug info
        debugInfo = [];
        addDebugMessage("Restarting playback");
        updateDebugDisplay();
        
        // Start playback
        startSynchronizedPlayback();
    }

    // ENHANCED: Add debug message
    function addDebugMessage(message) {
        const timestamp = new Date().toISOString().substr(11, 8);
        debugInfo.push(`[${timestamp}] ${message}`);
        
        // Keep only the last 50 messages
        if (debugInfo.length > 50) {
            debugInfo.shift();
        }
        // Update display immediately for important messages
        updateDebugDisplay(); 
    }

    // ENHANCED: Update debug info with current state
    function updateDebugInfo(currentTime) {
        // This function is now less critical as handleSynchronization updates debug
        // Can be used for less frequent status updates if needed
    }

    // ENHANCED: Update debug display
    function updateDebugDisplay() {
        const debugContentElement = document.getElementById('debug-content');
        if (!debugContentElement) return;
        
        debugContentElement.innerHTML = debugInfo.join('<br>');
        
        // Scroll to bottom
        debugContentElement.scrollTop = debugContentElement.scrollHeight;
    }

    // Update overlay position
    function updateOverlayPosition() {
        const container = document.getElementById('youtube-container');
        
        // Remove all position classes
        container.classList.remove('overlay-top-right', 'overlay-top-left', 'overlay-bottom-right', 'overlay-bottom-left');
        
        // Add selected position class
        container.classList.add('overlay-' + overlayPosition);
    }

    // Update overlay size - 모든 화면에서 동일하게 작동
    function updateOverlaySize() {
        const container = document.getElementById('youtube-container');
        if (container) {
            const sizeValue = Math.max(10, Math.min(overlaySize, 60)) + '%';
            container.style.width = sizeValue;
            
            // 모든 화면에서 16:9 비율 보장 (모바일과 데스크탑 통일)
            container.style.height = 'auto';
            container.style.aspectRatio = '16 / 9';
        }
    }

    // Update overlay visibility
    function updateOverlayVisibility() {
        const container = document.getElementById('youtube-container');
        container.style.display = isOverlayVisible && youtubeStarted ? 'block' : 'none';
    }

    // Update YouTube volume
    function updateYoutubeVolume() {
        if (youtubePlayer) {
            youtubePlayer.setVolume(youtubeVolume);
        }
    }

    // Extract YouTube video ID from URL
    function extractYouTubeVideoId(url) {
        const regExp = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#&?]*).*/;
        const match = url.match(regExp);
        return (match && match[7].length === 11) ? match[7] : null;
    }

    // Enable/disable controls
    function enableControls(enabled) {
        document.getElementById('play-btn').disabled = !enabled;
        document.getElementById('pause-btn').disabled = !enabled;
        document.getElementById('stop-btn').disabled = !enabled;
        document.getElementById('restart-btn').disabled = !enabled;
        document.getElementById('toggle-overlay').disabled = !enabled;
    }

    // Update button states
    function updateButtonStates(playing) {
        document.getElementById('play-btn').disabled = playing;
        document.getElementById('pause-btn').disabled = !playing;
        document.getElementById('stop-btn').disabled = !playing;
        document.getElementById('restart-btn').disabled = !playing;
    }

    // Show message
    function showMessage(text, type) {
        const messageElement = document.getElementById('message');
        messageElement.textContent = text;
        messageElement.className = `message ${type}`;
        messageElement.style.display = 'block';
        
        // Auto-hide success messages after 5 seconds
        if (type === 'success') {
            setTimeout(function() {
                if (messageElement.textContent === text) { // Clear only if message hasn't changed
                     messageElement.style.display = 'none';
                }
            }, 5000);
        }
    }

    // Hide message
    function hideMessage() {
        const messageElement = document.getElementById('message');
        messageElement.style.display = 'none';
    }

    // Load VE URL data from server
    function loadVEUrlFromServer(veId) {
        console.log("📡 Loading VE URL from server:", veId);
        addDebugMessage(`📡 Loading VE URL from server: ${veId}`);
        
        // Determine server URL
        const serverUrl = window.location.origin;
        const apiUrl = `${serverUrl}/api/ve-urls/${veId}`;
        
        console.log("🔗 API URL:", apiUrl);
        addDebugMessage(`🔗 API URL: ${apiUrl}`);
        
        fetch(apiUrl)
            .then(response => {
                console.log("📥 Response status:", response.status);
                addDebugMessage(`📥 Response status: ${response.status}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log("✅ VE URL data loaded successfully:", data);
                addDebugMessage("✅ VE URL data loaded successfully");
                addDebugMessage(`📊 Data structure: ${JSON.stringify(data, null, 2)}`);
                
                // Setup viewer with server data
                setupViewerWithServerData(data);
            })
            .catch(error => {
                console.error("❌ Failed to load VE URL from server:", error);
                addDebugMessage(`❌ Failed to load VE URL from server: ${error.message}`);
                showMessage('Failed to load VE URL data. Please check the URL.', 'error');
            });
    }

    // Setup viewer with server data
    function setupViewerWithServerData(data) {
        try {
            // Extract data from server response
            const veUrlData = data.ve_url;
            const timestampData = veUrlData.timestamp_data;
            const reactionUrl = veUrlData.reaction_url;
            const youtubeUrl = veUrlData.original_url;
            
            console.log("🔧 Setting up viewer with server data");
            addDebugMessage("🔧 Setting up viewer with server data");
            
            // Set timestamp data
            if (timestampData && timestampData.sync_points && timestampData.sync_points.length > 0) {
                // Clear existing events
                pauseEvents = [];
                playEvents = [];
                debugInfo = [];
                
                // Process all events
                timestampData.sync_points.forEach(point => {
                    // Store first play time
                    if (point.youtube_first_play_time !== undefined && point.youtube_first_play_time !== null) {
                        youtubeFirstPlayTime = point.youtube_first_play_time;
                    }
                    
                    // Categorize events
                    if (point.event === 'youtube_pause') {
                        pauseEvents.push(point);
                    } else if (point.event === 'youtube_play') {
                        playEvents.push(point);
                    }
                });
                
                // Sort events by reaction_time
                pauseEvents.sort((a, b) => a.reaction_time - b.reaction_time);
                playEvents.sort((a, b) => a.reaction_time - b.reaction_time);
                
                // Find first sync point (first play event)
                firstSyncPoint = playEvents.length > 0 ? playEvents[0] : null;
                
                if (firstSyncPoint) {
                    console.log("First sync point loaded:", firstSyncPoint);
                    console.log("All pause events:", pauseEvents);
                    console.log("All play events:", playEvents);
                    
                    addDebugMessage("Timestamp data loaded successfully");
                    addDebugMessage(`Found ${playEvents.length} play events and ${pauseEvents.length} pause events`);
                    
                    // Log all events for debugging
                    playEvents.forEach(event => {
                        addDebugMessage(`Play event at ${event.reaction_time.toFixed(2)}s -> YouTube ${event.relative_youtube_time.toFixed(2)}s`);
                    });
                    
                    pauseEvents.forEach(event => {
                        addDebugMessage(`Pause event at ${event.reaction_time.toFixed(2)}s -> YouTube ${event.relative_youtube_time.toFixed(2)}s`);
                    });
                }
            }
            
            // Set reaction URL
            if (reactionUrl) {
                const reactionUrlElement = document.getElementById('reaction-url');
                if (reactionUrlElement) {
                    reactionUrlElement.value = reactionUrl;
                }
                
                // Extract reaction video YouTube ID
                const reactionVideoId = extractYouTubeVideoId(reactionUrl);
                if (reactionVideoId) {
                    // Remove existing reaction YouTube player
                    if (reactionYoutubePlayer) {
                        reactionYoutubePlayer.destroy();
                        reactionYoutubePlayer = null;
                    }
                    
                    // Set YouTube-YouTube mode flag
                    youtubeYoutubeMode = true;
                    reactionYoutubeReady = false;
                    
                    // Create new reaction YouTube player
                    // 모바일 감지 및 해상도 최적화
                    const isMobile = window.innerWidth <= 768;
                    const playerVars = isMobile ? {
                        'playsinline': 1,
                        'controls': 1,
                        'autoplay': 0,
                        'rel': 0,
                        'vq': 'large',  // 메인 영상은 높은 해상도 (480p) - 좋은 화질
                        'iv_load_policy': 3,  // 주석 비활성화
                        'cc_load_policy': 0   // 자막 비활성화
                    } : {
                        'playsinline': 1,
                        'controls': 1,
                        'autoplay': 0,
                        'rel': 0,
                        'vq': 'medium' // 데스크탑 메인 영상은 중간 해상도 (360p) - 적절한 화질
                    };
                    
                    reactionYoutubePlayer = new YT.Player('reaction-youtube-container', {
                        height: '540',
                        width: '100%',
                        videoId: reactionVideoId,
                        playerVars: playerVars,
                        events: {
                            'onReady': onReactionPlayerReady,
                            'onStateChange': onReactionPlayerStateChange
                        }
                      });
                      
                      addDebugMessage(`Created reaction YouTube player with video ID: ${reactionVideoId}`);
                }
            }
            
            // Set YouTube URL
            if (youtubeUrl) {
                const youtubeUrlElement = document.getElementById('youtube-url');
                if (youtubeUrlElement) {
                    youtubeUrlElement.value = youtubeUrl;
                }
                
                // Extract YouTube video ID
                youtubeVideoId = extractYouTubeVideoId(youtubeUrl);
                if (youtubeVideoId) {
                    // Hide YouTube container until first sync point
                    document.getElementById('youtube-container').style.display = 'none';
                    
                    addDebugMessage(`YouTube video ID extracted: ${youtubeVideoId}`);
                }
            }
            
            // Apply server settings
            if (veUrlData.settings) {
                console.log("🔧 Applying server settings:", veUrlData.settings);
                addDebugMessage("🔧 Applying server settings");
                
                // Apply overlay position
                if (veUrlData.settings.overlay_position) {
                    const overlayPositionSelect = document.getElementById('overlay-position');
                    if (overlayPositionSelect) {
                        overlayPositionSelect.value = veUrlData.settings.overlay_position;
                        overlayPosition = veUrlData.settings.overlay_position;
                        updateOverlayPosition();
                    }
                }
                
                        // Apply overlay size
        if (veUrlData.settings.overlay_size) {
            const overlaySizeSlider = document.getElementById('overlay-size');
            const overlaySizeValue = document.getElementById('overlay-size-value');
            if (overlaySizeSlider) {
                overlaySizeSlider.value = veUrlData.settings.overlay_size;
                overlaySizeValue.textContent = veUrlData.settings.overlay_size + '%';
                overlaySize = veUrlData.settings.overlay_size;
                updateOverlaySize();
            }
        }
                
                // Apply YouTube volume
                if (veUrlData.settings.youtube_volume) {
                    const youtubeVolumeSlider = document.getElementById('youtube-volume');
                    const youtubeVolumeValue = document.getElementById('youtube-volume-value');
                    if (youtubeVolumeSlider) {
                        youtubeVolumeSlider.value = veUrlData.settings.youtube_volume;
                        youtubeVolumeValue.textContent = veUrlData.settings.youtube_volume + '%';
                        youtubeVolume = veUrlData.settings.youtube_volume;
                        updateYoutubeVolume();
                    }
                }
                
                // Apply hide overlay setting
                if (veUrlData.settings.hide_overlay !== undefined) {
                    isOverlayVisible = !veUrlData.settings.hide_overlay;
                    updateOverlayVisibility();
                    const toggleOverlayBtn = document.getElementById('toggle-overlay');
                    if (toggleOverlayBtn) {
                        toggleOverlayBtn.textContent = isOverlayVisible ? 'Hide Overlay' : 'Show Overlay';
                    }
                }
            }
            
            // Update video info section
            updateVideoInfo(veUrlData);
            
            // Update status
            console.log('Status updated');
            enableControls(true);
            updateDebugDisplay();
            
            // Auto-start playback after a short delay to ensure everything is ready
            setTimeout(() => {
                autoStartPlayback();
            }, 1000);
            
        } catch (error) {
            console.error("❌ Error setting up viewer with server data:", error);
            addDebugMessage(`❌ Error setting up viewer with server data: ${error.message}`);
            showMessage('Error setting up viewer with server data.', 'error');
        }
    }

    // Auto-start playback function
    function autoStartPlayback() {
        try {
            console.log('🎬 Auto-starting playback...');
            addDebugMessage('🎬 Auto-starting playback...');
            
            // Check if all required data is loaded
            if (!youtubeVideoId) {
                console.log('❌ YouTube video ID not loaded yet');
                addDebugMessage('❌ YouTube video ID not loaded yet');
                return;
            }
            
            if (!reactionYoutubeReady) {
                console.log('❌ Reaction YouTube player not ready yet');
                addDebugMessage('❌ Reaction YouTube player not ready yet');
                return;
            }
            
            // Check if play button is enabled
            const playButton = document.getElementById('play-btn');
            if (playButton && !playButton.disabled) {
                console.log('✅ All conditions met, starting playback...');
                addDebugMessage('✅ All conditions met, starting playback...');
                
                // Trigger play button click
                playButton.click();
            } else {
                console.log('❌ Play button is disabled');
                addDebugMessage('❌ Play button is disabled');
            }
            
        } catch (error) {
            console.error('❌ Error in auto-start playback:', error);
            addDebugMessage(`❌ Error in auto-start playback: ${error.message}`);
        }
    }

    // Auto-load for VE server mode
    function autoLoadForVEServer() {
        const urlParams = new URLSearchParams(window.location.search);
        const veId = urlParams.get('ve');
        
        if (veId) {
            console.log("🔄 Auto-loading VE URL data");
            addDebugMessage("🔄 Auto-loading VE URL data");
            loadVEUrlFromServer(veId);
        }
    }

    // Global variables for video info
    let currentVideoData = null;
    let currentCreatorId = null;

    // Update video info section with server data
    function updateVideoInfo(videoData) {
        currentVideoData = videoData;
        currentCreatorId = videoData.creator_info?.user_id;
        
        
        // Show video info section (already visible by default)
        // document.getElementById('videoInfoSection').style.display = 'block';
        
        // Update title
        document.getElementById('videoTitleMain').textContent = videoData.title || 'Untitled Video';
        
        // Update view count and date
        const viewCount = videoData.metadata?.view_count || 0;
        const createdDate = videoData.metadata?.created_at ? new Date(videoData.metadata.created_at) : new Date();
        const formattedDate = createdDate.toLocaleDateString('en-US', { 
            year: 'numeric', 
            month: 'short', 
            day: 'numeric' 
        });
        
        document.getElementById('viewCount').textContent = formatViewCount(viewCount);
        document.getElementById('uploadDate').textContent = `• ${formattedDate}`;
        
        // Update channel info
        const creatorName = videoData.creator_info?.nickname || 'Anonymous';
        const creatorInitial = creatorName.charAt(0).toUpperCase();
        
        document.getElementById('channelAvatar').textContent = creatorInitial;
        document.getElementById('channelName').textContent = creatorName;
        
        // Load actual subscriber count
        loadSubscriberCount();
        
        // Update description with better formatting
        const description = videoData.description || 'No description available.';
        const descriptionElement = document.getElementById('videoDescription');
        
        if (description && description.trim() !== '') {
            // Convert line breaks to HTML and preserve formatting
            const formattedDescription = description
                .replace(/\n/g, '<br>')
                .replace(/\r\n/g, '<br>')
                .replace(/\r/g, '<br>');
            descriptionElement.innerHTML = formattedDescription;
        } else {
            descriptionElement.textContent = 'No description available.';
        }
        
        // Update like count
        const likeCount = videoData.react_central?.likes || 0;
        document.getElementById('likeCount').textContent = formatCount(likeCount);
        
        
        // Check subscription status
        checkSubscriptionStatus();
        
        // Check like and bookmark status
        checkLikeAndBookmarkStatus();
        
        // Load sidebar content
        loadSidebarContent();
    }

    // Format view count
    function formatViewCount(count) {
        if (count >= 1000000) {
            return `${(count / 1000000).toFixed(1)}M views`;
        } else if (count >= 1000) {
            return `${(count / 1000).toFixed(1)}K views`;
        } else {
            return `${count} views`;
        }
    }

    // Format count
    function formatCount(count) {
        if (count >= 1000) {
            return `${(count / 1000).toFixed(1)}K`;
        }
        return count.toString();
    }

    // Refresh like count from server
    async function refreshLikeCount() {
        try {
            if (!currentVideoData || !currentVideoData.ve_id) return;
            
            const response = await fetch(`/api/react-central/videos/${currentVideoData.ve_id}`);
            
            if (response.ok) {
                const data = await response.json();
                const likeCount = data.video?.react_central?.likes || 0;
                document.getElementById('likeCount').textContent = formatCount(likeCount);
            }
        } catch (error) {
            console.error('Error refreshing like count:', error);
        }
    }

    // Load subscriber count from server
    async function loadSubscriberCount() {
        try {
            if (!currentCreatorId) {
                document.getElementById('subscriberCount').textContent = '0 subscribers';
                return;
            }
            
            const response = await fetch(`/api/user/${currentCreatorId}/subscribers-count`);
            
            if (response.ok) {
                const data = await response.json();
                const count = data.subscriberCount || 0;
                const formattedCount = formatSubscriberCount(count);
                document.getElementById('subscriberCount').textContent = formattedCount;
            } else {
                document.getElementById('subscriberCount').textContent = '0 subscribers';
            }
        } catch (error) {
            console.error('Error loading subscriber count:', error);
            document.getElementById('subscriberCount').textContent = '0 subscribers';
        }
    }

    // Format subscriber count
    function formatSubscriberCount(count) {
        if (count === 0) {
            return '0 subscribers';
        } else if (count === 1) {
            return '1 subscriber';
        } else if (count >= 1000000) {
            return `${(count / 1000000).toFixed(1)}M subscribers`;
        } else if (count >= 1000) {
            return `${(count / 1000).toFixed(1)}K subscribers`;
        } else {
            return `${count} subscribers`;
        }
    }

    // Refresh subscriber count (called after subscribe/unsubscribe)
    async function refreshSubscriberCount() {
        await loadSubscriberCount();
    }

    // Check subscription status
    async function checkSubscriptionStatus() {
        const token = localStorage.getItem('authToken');
        if (!token || !currentCreatorId) return;

        try {
            const response = await fetch('/api/user/subscriptions', {
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });
            
            if (response.ok) {
                const data = await response.json();
                const subscriptions = data.subscriptions || [];
                const isSubscribed = subscriptions.some(sub => sub._id === currentCreatorId);
                updateSubscriptionButton(isSubscribed);
            }
        } catch (error) {
            console.error('Error checking subscription status:', error);
        }
    }

    // Update subscription button
    function updateSubscriptionButton(isSubscribed) {
        const subscribeBtn = document.getElementById('subscribeBtn');
        const icon = subscribeBtn.querySelector('.material-icons');
        const text = subscribeBtn.querySelector('span:last-child');
        
        if (isSubscribed) {
            subscribeBtn.classList.add('subscribed');
            subscribeBtn.classList.remove('subscribe-btn');
            icon.textContent = 'notifications_active';
            text.textContent = 'Subscribed';
        } else {
            subscribeBtn.classList.remove('subscribed');
            subscribeBtn.classList.add('subscribe-btn');
            icon.textContent = 'notifications';
            text.textContent = 'Subscribe';
        }
    }

    // Check like and bookmark status
    async function checkLikeAndBookmarkStatus() {
        const token = localStorage.getItem('authToken');
        if (!token || !currentVideoData) return;

        try {
            // Check bookmark status
            const bookmarksResponse = await fetch('/api/user/bookmarks', {
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });

            if (bookmarksResponse.ok) {
                const bookmarksData = await bookmarksResponse.json();
                const bookmarks = bookmarksData.bookmarks || [];
                const isBookmarked = bookmarks.includes(currentVideoData.ve_id);
                
                const bookmarkBtn = document.getElementById('bookmarkBtn');
                if (isBookmarked) {
                    bookmarkBtn.classList.add('bookmarked');
                } else {
                    bookmarkBtn.classList.remove('bookmarked');
                }
            }

            // Check like status (from localStorage for now)
            const isLiked = localStorage.getItem(`liked_${currentVideoData.ve_id}`);
            const likeBtn = document.getElementById('likeBtn');
            if (isLiked) {
                likeBtn.classList.add('liked');
            } else {
                likeBtn.classList.remove('liked');
            }

        } catch (error) {
            console.error('Error checking like and bookmark status:', error);
        }
    }

    // Toggle subscription
    async function toggleSubscription() {
        const token = localStorage.getItem('authToken');
        if (!token) {
            alert('Please log in to subscribe to channels');
            return;
        }

        if (!currentCreatorId) {
            alert('Creator information not available');
            return;
        }

        const subscribeBtn = document.getElementById('subscribeBtn');
        const isSubscribed = subscribeBtn.classList.contains('subscribed');
        const action = isSubscribed ? 'unsubscribe' : 'subscribe';
        
        try {
            const response = await fetch('/api/user/subscription', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify({ 
                    creator_id: currentCreatorId,
                    action: action
                })
            });
            
            if (!response.ok) {
                throw new Error(`Failed to update subscription: ${response.status}`);
            }

            const data = await response.json();
            
            if (data.action === 'subscribed' || data.action === 'unsubscribed') {
                updateSubscriptionButton(data.action === 'subscribed');
                // Refresh subscriber count after subscription change
                await refreshSubscriberCount();
            }
            
        } catch (error) {
            console.error('Subscription error:', error);
            alert('Failed to update subscription. Please try again.');
        }
    }

    // Toggle like using react-central logic
    async function toggleLike() {
        const token = localStorage.getItem('authToken');
        if (!token) {
            alert('Please log in to like videos');
            return;
        }

        if (!currentVideoData || !currentVideoData.ve_id) {
            alert('Video information not available');
            return;
        }

        const likeBtn = document.getElementById('likeBtn');
        const isLiked = likeBtn.classList.contains('liked');
        const action = isLiked ? 'unlike' : 'like';
        
        try {
            const response = await fetch(`/api/react-central/videos/${currentVideoData.ve_id}/like`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify({ action })
            });
            
            if (!response.ok) {
                throw new Error(`Failed to update like: ${response.status}`);
            }

            // Update UI based on action
            if (action === 'like') {
                likeBtn.classList.add('liked');
                localStorage.setItem(`liked_${currentVideoData.ve_id}`, 'true');
            } else {
                likeBtn.classList.remove('liked');
                localStorage.removeItem(`liked_${currentVideoData.ve_id}`);
            }
            
            // Refresh like count from server to get accurate count
            await refreshLikeCount();
            
        } catch (error) {
            console.error('Like error:', error);
            alert('Failed to update like. Please try again.');
        }
    }

    // Toggle bookmark using react-central logic
    async function toggleBookmark() {
        const token = localStorage.getItem('authToken');
        if (!token) {
            alert('Please log in to bookmark videos');
            return;
        }

        if (!currentVideoData || !currentVideoData.ve_id) {
            alert('Video information not available');
            return;
        }

        const bookmarkBtn = document.getElementById('bookmarkBtn');
        
        try {
            const response = await fetch('/api/user/bookmark', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify({ ve_id: currentVideoData.ve_id })
            });
            
            if (!response.ok) {
                throw new Error(`Failed to update bookmark: ${response.status}`);
            }

            const data = await response.json();
            
            if (data.action === 'added') {
                bookmarkBtn.classList.add('bookmarked');
            } else if (data.action === 'removed') {
                bookmarkBtn.classList.remove('bookmarked');
            }
            
        } catch (error) {
            console.error('Bookmark error:', error);
            alert('Failed to update bookmark. Please try again.');
        }
    }

    // Load sidebar content
    async function loadSidebarContent() {
        try {
            // Load latest videos
            await loadLatestVideos();
            
            // Load popular videos
            await loadPopularVideos();
            
            
        } catch (error) {
            console.error('Error loading sidebar content:', error);
        }
    }

    // Load latest videos
    async function loadLatestVideos() {
        try {
            const response = await fetch('/api/react-central/videos?sort=latest&limit=5');
            if (response.ok) {
                const data = await response.json();
                const videos = data.videos || [];
                renderVideoList('latestVideos', videos);
            }
        } catch (error) {
            console.error('Error loading latest videos:', error);
            // Show placeholder content
            document.getElementById('latestVideos').innerHTML = '<p style="color: var(--dark-text-secondary); padding: 8px;">No videos available</p>';
        }
    }

    // Load popular videos
    async function loadPopularVideos() {
        try {
            const response = await fetch('/api/react-central/videos?sort=popular&limit=5');
            if (response.ok) {
                const data = await response.json();
                const videos = data.videos || [];
                renderVideoList('popularVideos', videos);
            }
        } catch (error) {
            console.error('Error loading popular videos:', error);
            // Show placeholder content
            document.getElementById('popularVideos').innerHTML = '<p style="color: var(--dark-text-secondary); padding: 8px;">No videos available</p>';
        }
    }

    // Render video list
    function renderVideoList(containerId, videos) {
        const container = document.getElementById(containerId);
        if (!container) return;

        if (videos.length === 0) {
            container.innerHTML = '<p style="color: var(--dark-text-secondary); padding: 8px;">No videos available</p>';
            return;
        }

        const html = videos.map(video => {
            const thumbnailUrl = getThumbnailUrl(video.reaction_url);
            const viewCount = formatViewCount(video.metadata?.view_count || 0);
            const uploadDate = formatUploadDate(video.metadata?.created_at);
            const channelName = video.creator_info?.nickname || 'Anonymous';
            const isVerified = Math.random() > 0.5; // Random verification for demo
            
            return `
                <div class="video-item" onclick="loadVideo('${video.ve_id}')">
                    <div class="video-thumbnail">
                        <img src="${thumbnailUrl}" alt="${video.title}" onerror="this.style.display='none'">
                    </div>
                    <div class="video-info">
                        <div class="video-item-title">${video.title || 'Untitled'}</div>
                        <div class="video-item-channel">
                            ${channelName}
                            ${isVerified ? '<span class="channel-verified">✓</span>' : ''}
                        </div>
                        <div class="video-item-stats">${viewCount} • ${uploadDate}</div>
                    </div>
                </div>
            `;
        }).join('');

        container.innerHTML = html;
    }


    // Helper functions
    function getThumbnailUrl(reactionUrl) {
        if (!reactionUrl) return '';
        const videoId = extractYouTubeVideoId(reactionUrl);
        return videoId ? `https://img.youtube.com/vi/${videoId}/mqdefault.jpg` : '';
    }


    function formatUploadDate(dateString) {
        if (!dateString) return 'Unknown';
        const date = new Date(dateString);
        const now = new Date();
        const diffTime = Math.abs(now - date);
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        
        if (diffDays === 1) return '1 day ago';
        if (diffDays < 7) return `${diffDays} days ago`;
        if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
        return `${Math.floor(diffDays / 30)} months ago`;
    }

    // Load video function
    function loadVideo(veId) {
        window.location.href = `viewer.html?ve=${veId}`;
    }

    // Tab switching functionality
    function initSidebarTabs() {
        const tabs = document.querySelectorAll('.sidebar-tab');
        const sections = {
            latest: document.getElementById('latestSection'),
            popular: document.getElementById('popularSection')
        };

        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const tabType = tab.dataset.tab;
                
                // Remove active class from all tabs
                tabs.forEach(t => t.classList.remove('active'));
                
                // Add active class to clicked tab
                tab.classList.add('active');
                
                // Hide all sections
                Object.values(sections).forEach(section => {
                    section.style.display = 'none';
                });
                
                // Show selected section
                if (sections[tabType]) {
                    sections[tabType].style.display = 'block';
                }
            });
        });
    }

    // Initialize sidebar tabs when DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
        initSidebarTabs();
        checkAuthStatus(); // 인증 상태 확인하여 프로필 메뉴 업데이트
    });

    // Check authentication status and update profile menu
    function checkAuthStatus() {
        const token = localStorage.getItem('authToken');
        const user = localStorage.getItem('user');
        const profileMenu = document.getElementById('profileMenu');
        
        if (token && user) {
            try {
                const userData = JSON.parse(user);
                // 로그인된 상태 - 프로필 메뉴 표시
                profileMenu.innerHTML = `
                    <div class="profile-menu-item" onclick="goToProfile()">My Profile</div>
                    <div class="profile-menu-item" onclick="goToMyVideos()">My Videos</div>
                    <div class="profile-menu-item" onclick="goToMyBookmarks()">My Bookmarks</div>
                    <div class="profile-menu-item" onclick="logout()">Sign Out</div>
                `;
            } catch (error) {
                console.error('Error parsing user data:', error);
                // 로그인 안된 상태로 처리
                showLoginMenu();
            }
        } else {
            // 로그인 안된 상태
            showLoginMenu();
        }
    }
    
    function showLoginMenu() {
        const profileMenu = document.getElementById('profileMenu');
        profileMenu.innerHTML = `
            <div class="profile-menu-item" onclick="goToLogin()">Sign In</div>
            <div class="profile-menu-item" onclick="goToSignup()">Sign Up</div>
        `;
    }
    
    function goToLogin() {
        window.location.href = '/login.html';
    }
    
    function goToSignup() {
        window.location.href = '/signup.html';
    }
    
    function toggleProfileMenu() {
        const menu = document.getElementById('profileMenu');
        menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
    }
    
    function goToProfile() {
        window.location.href = '/profile.html';
    }
    
    function goToMyVideos() {
        window.location.href = '/react-central.html?category=my';
    }
    
    function goToMyBookmarks() {
        window.location.href = '/react-central.html?section=bookmarks';
    }
    
    function logout() {
        localStorage.removeItem('authToken');
        localStorage.removeItem('user');
        
        // Clear user-specific data
        localStorage.removeItem('bookmarks');
        
        // Clear all liked/bookmarked video states
        const keysToRemove = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && (key.startsWith('liked_') || key.startsWith('bookmarked_') || key.startsWith('subscribed_'))) {
                keysToRemove.push(key);
            }
        }
        keysToRemove.forEach(key => localStorage.removeItem(key));
        
        window.location.href = '/index.html';
    }

    // Header functions from react-central
    function toggleSidebar() {
        window.location.href = '/react-central.html';
    }

    function performSearch() {
        const searchTerm = document.getElementById('searchInput').value.trim();
        if (searchTerm) {
            // Redirect to react-central with search
            window.location.href = `/react-central.html?search=${encodeURIComponent(searchTerm)}`;
        }
    }

    function toggleMobileSearch() {
        const searchInput = document.getElementById('searchInput');
        if (searchInput) {
            searchInput.focus();
        } else {
            // If no search input, redirect to react-central
            window.location.href = '/react-central.html';
        }
    }

    function toggleProfileMenu() {
        const menu = document.getElementById('profileMenu');
        menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
    }

    function goToProfile() {
        window.location.href = 'profile.html';
    }

    function goToMyVideos() {
        window.location.href = '/react-central.html?category=my';
        toggleProfileMenu();
    }

    function goToMyBookmarks() {
        window.location.href = '/react-central.html?category=bookmarks';
        toggleProfileMenu();
    }

    function logout() {
        localStorage.removeItem('authToken');
        localStorage.removeItem('user');
        
        // Clear user-specific data
        localStorage.removeItem('bookmarks');
        
        // Clear all liked/bookmarked video states
        const keysToRemove = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && (key.startsWith('liked_') || key.startsWith('bookmarked_'))) {
                keysToRemove.push(key);
            }
        }
        keysToRemove.forEach(key => localStorage.removeItem(key));
        
        // Redirect to login
        window.location.href = '/login.html';
    }

    // Close profile menu when clicking outside
    document.addEventListener('click', function(event) {
        const profileBtn = document.getElementById('profileBtn');
        const profileMenu = document.getElementById('profileMenu');
        
        if (profileBtn && profileMenu && 
            !profileBtn.contains(event.target) && 
            !profileMenu.contains(event.target)) {
            profileMenu.style.display = 'none';
        }
    });

    // Search on Enter key
    document.addEventListener('DOMContentLoaded', function() {
        const searchInput = document.getElementById('searchInput');
        if (searchInput) {
            searchInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    performSearch();
                }
            });
        }
    });

    </script>
</body>
</html>

